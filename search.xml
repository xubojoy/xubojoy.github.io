<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[线程安全以及nonatomic和atomic]]></title>
    <url>%2F2018%2F03%2F05%2F%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%BB%A5%E5%8F%8Anonatomic%E5%92%8Catomic%2F</url>
    <content type="text"><![CDATA[atomic在set方法里加了锁，防止了多线程一直去写这个property，造成难以预计的数值。但这也只是读写的锁定。并不能保证一定是线程安全的，最好的方式是加锁。但是有个很大的问题就是造成读写很慢。 借用别人一形象比喻：比如你开了一个服装店，这个服装店有三层，在第三层有个只能容纳一人试衣间，今天要来5个人买衣服，第一个人看上了一件衣服，要去试试，你告诉他位置他就去了，这时候试衣间的可容纳人数已经是0，这时候第二个人也要去试衣服，你也告诉他位置，他就去了，去了之后打开门，注意，这里能打开门，所以在他看来，这里是能进去的，但是打开门就尴尬了，然后这个时候两个人可能就干起来了，这个时候两个人（多线程）同时访问了这个试衣间（内存），造成了线程的不安全（容纳人数是这个内存中的数据），造成了错误，第一个人可能就说了，我已经先来了，把这块区域占了，已经在使用这个数据了，第二个人就会说，是老板跟我所试衣间在这里，我也要使用试衣间，我一拉门就开了，我以为里面没人。那么怎么解决这样的线程不安全呢？当然一看就知道，给这个门加个锁就行了，客户进来试衣服就把门锁上，第二个人来了，发现门打不开，就不会立即使用这个数据，等第一个人开锁出来了，第二个人再进去，这样数据就是安全的了，不会产生错误。关于加锁的位置也有说法，因为加锁是很耗资源的，所以锁的位置要放对，也不要多放，比如来买衣服，进来一个人你直接把服装店的大门就锁上了，就浪费了其他人选衣服的时间（要放对位置）；第一个人选好了衣服，准备去试衣服，你直接把一楼，二楼，三楼，试衣间全锁上了，那这个人试玩衣服出来解完全部的锁，要花费大量的时间（浪费资源），当然这样也是没有必要的（不要多放）。只要在试衣间门上面上个锁就行了。 关于nonatomic和atomic也是一样，nonatomic线程不安全，atomic线程安全，具体表现在变量是setter方法有没有加锁。如果用atomic修饰就相当于每个人出生你就给他搞了个可携带式的加锁试衣间，不管干什么，都要先解锁，来买个衣服，先解了锁从试衣间出来跟你说话，说完又进去，解锁出来看衣服，看完再进去，很耗资源，所以建议我们使用nonatomic，先不装试衣间，只要在需要用的地方（比如你的服装店）搞个加锁的试衣间就可以。]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何用HTTP实现长连接]]></title>
    <url>%2F2018%2F02%2F26%2F%E5%A6%82%E4%BD%95%E7%94%A8HTTP%E5%AE%9E%E7%8E%B0%E9%95%BF%E8%BF%9E%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[http是一种无状态的协议，也就是stateless协议，而http协议又是建立在tcp/ip协议的基础之上的。无状态表示每次请求都是一次独立的http事务，也就是发送http 请求（request）过去，然后web服务器或者application服务器进行响应，返回一个http response回来，这样就是结束了一次http事务。http建立在tcp/ip的基础之上，从而会遵循tcp协议的规则，在每次进行连接的时候，必须先进行三次握手，数据交换之后，进行四次断开。 http连接保持时间是由服务端的消息头connection字段和keep-alive字段决定的，connection字段只有服务端设置才有效 HTTP短连接（非持久连接）是指，客户端和服务端进行一次HTTP请求/响应之后，就关闭连接。所以，下一次的HTTP请求/响应操作就需要重新建立连接。 HTTP长连接（持久连接）是指，客户端和服务端建立一次连接之后，可以在这条连接上进行多次请求/响应操作。持久连接可以设置过期时间，也可以不设置。 以HTTP1.1协议为例子。 设置HTTP短连接 在首部字段中设置Connection:close，则在一次请求/响应之后，就会关闭连接。 设置HTTP长连接，有过期时间 在首部字段中设置Connection:keep-alive 和Keep-Alive: timeout=60，表明连接建立之后，空闲时间超过60秒之后，就会失效。如果在空闲第58秒时，再次使用此连接，则连接仍然有效，使用完之后，重新计数，空闲60秒之后过期。 设置HTTP长连接，无过期时间 在首部字段中只设置Connection:keep-alive，表明连接永久有效。 不论request还是response的header中包含了值为close的connection，都表明当前正在使用的tcp连接在请求处理完毕后会被断掉。以后client再进行新的请求时就必须创建新的tcp链接了。 HTTP Connection的 close设置允许客户端或服务器中任何一方关闭底层的连接，双方都会要求在处理请求后关闭它们的TCP连接。 参考： HTTP长连接、短连接使用及测试 HTTP的长连接，你不知道的连接。。。]]></content>
  </entry>
  <entry>
    <title><![CDATA[如何设定线程池中线程的数目]]></title>
    <url>%2F2018%2F02%2F26%2F%E5%A6%82%E4%BD%95%E8%AE%BE%E5%AE%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%95%B0%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[线程池中线程的数目是跟线程池所要处理的任务性质有关的 任务的性质：CPU密集型任务、IO密集型任务、混合型任务。 任务的优先级：高、中、低。 任务的执行时间：长、中、短。 任务的依赖性：是否依赖其他系统资源，如数据库连接等。 性质不同的任务可以交给不同规模的线程池执行。针对不同的任务性质而言： CPU密集型任务应配置尽可能小的线程，如配置CPU个数+1的线程数， IO密集型任务应配置尽可能多的线程，因为IO操作不占用CPU，不要让CPU闲下来，应加大线程数量，如配置两倍CPU个数+1， 而对于混合型的任务，如果可以拆分，拆分成IO密集型和CPU密集型分别处理，前提是两者运行的时间是差不多的，如果处理时间相差很大，则没必要拆分了。 任务对其他系统资源有依赖：如某个任务依赖数据库的连接返回的结果，这时候等待的时间越长，则CPU空闲的时间越长，那么线程数量应设置得越大，才能更好的利用CPU。 线程等待时间所占比例越高，这样的话CPU空闲时间比较多，为了能够更好的利用CPU，需要较多线程。如果线程CPU时间所占比例越高，说明CPU比较繁忙，此时需要越少线程。另外，如果线程数量过多，线程之间的切换也会带来开销。 是否使用线程池就一定比使用单线程高效呢？答案是否定的，比如Redis就是单线程的，但它却非常高效，基本操作都能达到十万量级/s。从线程这个角度来看，部分原因在于：多线程带来线程上下文切换开销，单线程就没有这种开销。 参考：原文链接]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发中的八种锁(Lock)]]></title>
    <url>%2F2018%2F02%2F24%2FiOS%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%85%AB%E7%A7%8D%E9%94%81-Lock%2F</url>
    <content type="text"><![CDATA[介绍前先看一张之前的锁性能图表：不知道有没有跟我一样除了看@synchronized 和 NSLock眼熟 其他的根本不知道什么意思。于是怀着敬畏惭愧的心，赶紧学习下！ OSSpinLock (自旋锁)导入库 #import &lt;libkern/OSAtomic.h&gt; 🌰： __block OSSpinLock pinLock = OS_SPINLOCK_INIT; // 线程1dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ NSLog(@”线程 1 准备上锁 %d”,pinLock); OSSpinLockLock(&amp;pinLock); sleep(4); NSLog(@”线程1 %zd”,pinLock); OSSpinLockUnlock(&amp;pinLock); NSLog(@”线程1 解锁成功 %zd”, pinLock); NSLog(@”——————-“); }); // 线程2dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ NSLog(@”线程2 准备上锁 %zd”,pinLock); OSSpinLockLock(&amp;pinLock); NSLog(@”线程2 %zd”,pinLock); OSSpinLockUnlock(&amp;pinLock); NSLog(@”线程2 解锁成功 %zd”,pinLock); });可以发现即使加了异步线程，当线程1加锁之后，线程2会处于一直等待状态，直到线程1 解锁完成后，线程2才会执行。但是作为效率最优的锁，在 bireme的不再安全的OSSpinLock文中，已经指出潜在的bug：会导致优先级反转，因此不建议继续使用，目前已用os_unfair_lock锁替代,但是仅限iOS 10以后使用。 os_unfair_lock导入库 #import &lt;os/lock.h&gt; 🌰：1234567891011if (@available(iOS 10.0, *)) &#123; os_unfair_lock_t oslock = &amp;(OS_UNFAIR_LOCK_INIT); NSLog(@&quot;线程准备上锁 %zd&quot;,oslock); os_unfair_lock_lock(oslock); NSLog(@&quot;线程%zd&quot;,oslock); os_unfair_lock_unlock(oslock); NSLog(@&quot;解锁成功 %zd&quot;, oslock); NSLog(@&quot;-------------------&quot;);&#125; else &#123; Fallback on earlier versions&#125; 正常情况下，lock和unlock最好成对出现。 OS_SPINLOCK_INIT： 默认值为 0,在 locked 状态时就会大于 0，unlocked状态下为 0OSSpinLockLock(&amp;oslock)：上锁，参数为 OSSpinLock 地址OSSpinLockUnlock(&amp;oslock)：解锁，参数为 OSSpinLock 地址OSSpinLockTry(&amp;oslock)：尝试加锁，可以加锁则立即加锁并返回 YES,反之返回 NO 这里顺便提一下trylock和lock使用场景： 当前线程锁失败，也可以继续其它任务，用 trylock 合适当前线程只有锁成功后，才会做一些有意义的工作，那就 lock，没必要轮询 trylock dispatch_semaphore 信号量🌰： 12345678910111213141516171819 dispatch_semaphore_t signal = dispatch_semaphore_create(1);//传入值必须 &gt;=0, 若传入为0则阻塞线程并等待timeout,时间到后会执行其后的语句 dispatch_time_t overtime = dispatch_time(DISPATCH_TIME_NOW, 3.0f * NSEC_PER_SEC); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSLog(@&quot;线程等待1----%@&quot;,signal); dispatch_semaphore_wait(signal, overtime);//signal 值 -1 NSLog(@&quot;线程1&quot;); dispatch_semaphore_signal(signal); //signal 值 +1 NSLog(@&quot;线程发送信号1&quot;); NSLog(@&quot;--------------1----------------------&quot;); &#125;); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSLog(@&quot;线程等待2----%@&quot;,signal); dispatch_semaphore_wait(signal, overtime);//signal 值 -1 NSLog(@&quot;线程2&quot;); dispatch_semaphore_signal(signal); //signal 值 +1 NSLog(@&quot;线程发送信号2&quot;); NSLog(@&quot;----------2--------------------------&quot;); &#125;); 同样的信号量锁，会等一个线程执行完毕后，才会去执行另一个线程！dispatch_semaphore_create(1)： 传入值必须 &gt;=0, 若传入为 0 则阻塞线程并等待timeout,时间到后会执行其后的语句 传入0时: overtime会生效 传入&gt;0时: dispatch_semaphore_wait(signal, overTime)：相当于 lock,会使得 signal 值 -1dispatch_semaphore_signal(signal)：相当于 unlock,会使得 signal 值 +1 pthread_mutex 互斥锁🌰：1234567891011121314151617 static pthread_mutex_t pLock; pthread_mutex_init(&amp;pLock, NULL);dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSLog(@&quot;线程1 准备上锁&quot;); pthread_mutex_lock(&amp;pLock); sleep(3); NSLog(@&quot;线程1&quot;); pthread_mutex_unlock(&amp;pLock); NSLog(@&quot;线程1 解锁成功&quot;); NSLog(@&quot;----------------------&quot;); &#125;);dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSLog(@&quot;线程2 准备上锁&quot;); pthread_mutex_lock(&amp;pLock); NSLog(@&quot;线程2&quot;); pthread_mutex_unlock(&amp;pLock); &#125;); 打印结果： pthread_mutex 中也有个pthread_mutex_trylock(&amp;pLock)，和上面提到的 OSSpinLockTry(&amp;oslock)区别在于，前者可以加锁时返回的是 0，否则返回一个错误提示码；后者返回的 YES和NO pthread_mutex(recursive) 递归锁一般情况下加锁后只能有一个线程可以访问对象，需要排队，并且同一线程多次加锁也是不允许的，但是递归锁允许同一个线程在未释放其拥有的锁时反复对该锁进行加锁操作。 🌰：123456789101112131415161718static pthread_mutex_t pLock; pthread_mutexattr_t attr; pthread_mutexattr_init(&amp;attr); //初始化attr并且给它赋予默认 pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE); //设置锁类型，这边是设置为递归锁 pthread_mutex_init(&amp;pLock, &amp;attr); pthread_mutexattr_destroy(&amp;attr); //销毁一个属性对象，在重新进行初始化之前该结构不能重新使用dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; static void (^RecursiveBlock)(int); RecursiveBlock = ^(int value) &#123; pthread_mutex_lock(&amp;pLock); if (value &gt; 0) &#123; NSLog(@&quot;value: %d&quot;, value); RecursiveBlock(value - 1); &#125; pthread_mutex_unlock(&amp;pLock); &#125;; RecursiveBlock(5); &#125;); 此代码如果使用 pthread_mutex_init(&amp;pLock, NULL) 初始化会出现死锁的情况，递归锁恰能避免这种情况的发生； NSLock 普通锁🌰：123456789101112NSLock *myLock = [[NSLock alloc] init];dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [myLock lock]; sleep(5); NSLog(@&quot;线程1&quot;); [myLock unlock]; &#125;); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [myLock lock]; NSLog(@&quot;线程2&quot;); [myLock unlock]; &#125;); NSCondition此锁提供了几种方法： wait：进入等待状态 waitUntilDate:：让一个线程等待一定的时间 signal：唤醒一个等待的线程 broadcast：唤醒所有等待的线程 🌰：12345678NSCondition *cLock = [NSCondition new];dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSLog(@&quot;准备加锁&quot;); [cLock lock]; [cLock waitUntilDate:[NSDate dateWithTimeIntervalSinceNow:2]]; NSLog(@&quot;线程1&quot;); [cLock unlock]; &#125;); 等待2秒，唤醒一个线程 123456789101112131415161718192021222324NSCondition *cLock = [NSCondition new];//线程1dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [cLock lock]; NSLog(@&quot;线程1加锁成功&quot;); [cLock wait]; NSLog(@&quot;线程1&quot;); [cLock unlock];&#125;);//线程2dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [cLock lock]; NSLog(@&quot;线程2加锁成功&quot;); [cLock wait]; NSLog(@&quot;线程2&quot;); [cLock unlock];&#125;);dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; sleep(2); NSLog(@&quot;唤醒一个等待的线程&quot;); [cLock signal];&#125;); 结果打印： 等待2秒，唤醒所有等待线程 替换signal为broadcast 12345dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; sleep(2); NSLog(@&quot;唤醒所有等待的线程&quot;); [cLock broadcast];&#125;); 结果打印： NSRecursiveLock 递归锁🌰：12345678910111213NSRecursiveLock *rLock = [NSRecursiveLock new];dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; static void (^RecursiveBlock)(int); RecursiveBlock = ^(int value) &#123; [rLock lock]; if (value &gt; 0) &#123; NSLog(@&quot;线程%d&quot;, value); RecursiveBlock(value - 1); &#125; [rLock unlock]; &#125;; RecursiveBlock(4);&#125;); @synchronized🌰： 1234567891011121314//线程1dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; @synchronized (self) &#123; sleep(2); NSLog(@&quot;线程1&quot;); &#125;&#125;);//线程2dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; @synchronized (self) &#123; NSLog(@&quot;线程2&quot;); &#125;&#125;); NSConditionLock 条件锁🌰： 123456789101112131415161718192021222324 NSConditionLock *cLock = [[NSConditionLock alloc] initWithCondition:0]; //线程1dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; if([cLock tryLockWhenCondition:0])&#123; NSLog(@&quot;线程1&quot;); [cLock unlockWithCondition:1]; &#125;else&#123; NSLog(@&quot;失败&quot;); &#125; &#125;); //线程2dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [cLock lockWhenCondition:3]; NSLog(@&quot;线程2&quot;); [cLock unlockWithCondition:2]; &#125;); //线程3dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [cLock lockWhenCondition:1]; NSLog(@&quot;线程3&quot;); [cLock unlockWithCondition:3]; &#125;); 结果打印： 结果显示： 在初始化 NSConditionLock 对象时，给了默认标识为0 执行 tryLockWhenCondition:时，传入的条件标识也是 0,所以线程1 加锁成功 执行 unlockWithCondition:时，会把condition由 0 修改为 1因为condition 修改为了 1， 会先走到 线程3，然后 线程3 又将 condition 修改为 3 最后是线程2]]></content>
  </entry>
  <entry>
    <title><![CDATA[github上创建使用pod引用的项目]]></title>
    <url>%2F2018%2F02%2F07%2Fgithub%E4%B8%8A%E5%88%9B%E5%BB%BA%E4%BD%BF%E7%94%A8pod%E5%BC%95%E7%94%A8%E7%9A%84%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[这两天折腾cocoapods，折腾的也是够够的🐶，各种尝试发布自己的框架到github上，供其他人直接用pod安装。现在记录下过程： 首先必备技能：玩转git及github 一、打开www.github.com,创建自己的项目仓库大致就是这个样子，本文仓库名FJAlertView有关开原协议，这里采用MIT License,然后使用git clone [仓库地址],将仓库克隆到本地。二、将要测试的demo及要发布的开元框架放到仓库FJAlertView里,并创建.podspec文件.podspec文件的创建： pod spec create FJAlertView 此时的FJAlertView就是之后可以被搜索的pod名字 三、配置.podspec文件，这是我使用的是Sublime Text 123456789101112131415Pod::Spec.new do |s| s.name = &quot;FJAlertView&quot; s.version = &quot;0.0.4&quot; s.summary = &quot;a custom view for everyone FJAlertView.&quot; s.description = &lt;&lt;-DESC 自定义AlertView a custom view for everyone FJAlertView. DESC s.homepage = &quot;https://github.com/xubojoy/FJAlertView&quot; s.license = &quot;MIT&quot; s.author = &#123; &quot;xubojoy&quot; =&gt; &quot;xubojoy1112@163.com&quot; &#125; s.platform = :ios, &quot;7.0&quot; s.source = &#123; :git =&gt; &quot;https://github.com/xubojoy/FJAlertView.git&quot;, :tag =&gt; &quot;#&#123;s.version&#125;&quot; &#125; s.source_files = &quot;FJAlertView/*.&#123;h,m&#125;&quot; s.dependency &quot;Masonry&quot;, &quot;~&gt; 1.1.0&quot; name:类库的名称 version:库的版本 summary: 库的介绍 homtepage:Github上项目地址 license:许可证 author:作者 platform:运行的平台及最低支持版本 source:Github上项目的https链接地址 source_files:要共享的代码，这里是FJAlertView下面的所有代码。 dependency：第三方依赖库 四、创建相应的分支及tag标签 五、执行验证命令： pod lib lint FJAlertView.podspec 如上则就是验证成功！ 六、验证podspec pod spec lint FJAlertView.podspec 七、提交公有库 pod trunk push FJAlertView.podspec 整个过程到此完结，可以开始装逼了！！！🙃🙃🙃🙃🙃———-]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS字符串相关]]></title>
    <url>%2F2018%2F02%2F02%2FiOS%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[字符串倒序： //swift精简版 let str:String = "Hello,Swift，你好!" print("倒叙字符串\n\(String(str.reversed()))") //遍历字符串 for ch in str{ print("\(ch)") } //OC易理解版 - (NSString *)reverseStr:(NSString *)str{ NSMutableArray *strArray = [NSMutableArray new]; for (NSInteger i = 0; i < str.length; i ++) { NSString *tmp = [str substringWithRange:NSMakeRange(i, 1)]; [strArray addObject:tmp]; } NSArray *array = [[strArray reverseObjectEnumerator] allObjects]; NSLog(@"-->%@",array); NSString *reverseStr = [array componentsJoinedByString:@""]; NSLog(@"-reverseStr->%@",reverseStr); return reverseStr; } 12345678//OC版本二-(NSString *)inputValue:(NSString *)str&#123; NSMutableString *string=[[NSMutableString alloc] init]; for(int i=0;i&lt;str.length;i++)&#123; [string appendString:[str substringWithRange:NSMakeRange(str.length-i-1, 1)]]; &#125; return string;&#125;]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS使用shell命令一键打包]]></title>
    <url>%2F2018%2F01%2F29%2FiOS%E4%BD%BF%E7%94%A8shell%E5%91%BD%E4%BB%A4%E4%B8%80%E9%94%AE%E6%89%93%E5%8C%85%2F</url>
    <content type="text"><![CDATA[对于ios一件打包的好处自然是不言而喻，之前公司使用过shell打包分发，但是也是别人写的，而且要测试的环境也并不是太多，最近工作新公司项目要测试的环境实在太多，每次测试人员测试，都得给他们一个环境一个环境的用Xcode连接真机打包，实在麻烦，因此一直想研究下自动打包。 网上有关自动打包的教程很多，但是适合自己项目使用，亲自测试成功的才是最好的。 本文将通过使用bash脚本来实现。 首先介绍自动化打包之前，咱先介绍下自动化切换测试环境 对于自动化切换环境，我使用的是通过plist文件类控制API环境的切换： 一、创建单例类 比如AppStatus,之后根据自己项目需求添加属性.h中 @interface AppStatus : NSObject //统一请求的API接口 @property (nonatomic, strong) NSString *requestUrl; @property (nonatomic, strong) NSString *env; +(AppStatus *)sharedInstance; @end .m中实现 +(AppStatus *)sharedInstance{ static AppStatus *_sharedInstance = nil; static dispatch_once_t onceToken; dispatch_once(&onceToken, ^{ if(_sharedInstance == nil){ _sharedInstance = [[AppStatus alloc] init]; } NSDictionary *dicInfo = [[NSBundle mainBundle] infoDictionary]; _sharedInstance.requestUrl = [dicInfo objectForKey:@"requestUrl"]; _sharedInstance.env = [dicInfo objectForKey:@"env"]; }); return _sharedInstance; } plist文件添加字段requestUrl和 env 二、新建bash脚本放在项目根目录，与info.plist同级脚本如下，如:update_plist脚本 \#!/bin/bash \# $1 = xxx 工程名称 \# $2 = test 环境(比如测试环境) \#脚本所需参数 targetName=$1 env=$2 \#项目目录 projectHome=\`pwd` \# plist文件路径 buildPlist=/$projectHome/$targetName/Info.plist plistBuddy=/usr/libexec/PlistBuddy \#app param \#test环境 \#APP名称---> Bundle display name product\_appName="APP名称" \#项目的bundle id 如： product\_bundleIdentifier="com.xxx.xxxx" \#要测试的环境 如：生产环境---> product product\_env="test" \#自己的API请求地址 如： product\_requestUrl="https://test.xxxxx.com/" \#product环境 product\_appName="APP名称" product\_bundleIdentifier="com.xxx.xxxx" product\_env="product" product\_requestUrl="https://www.xxxxx.com/" \#环境判断 if [ $env = 'test' ]; then echo '进if了test ' $plistBuddy -c "Set :requestUrl $test\_requestUrl" $buildPlist $plistBuddy -c "Set :CFBundleDisplayName $test\_appName" $buildPlist $plistBuddy -c "Set :CFBundleIdentifier $test\_bundleIdentifier" $buildPlist $plistBuddy -c "Set :env $test\_env" $buildPlist else echo '进else了product ' $plistBuddy -c "Set :requestUrl $product\_requestUrl" $buildPlist $plistBuddy -c "Set :CFBundleDisplayName $product\_appName" $buildPlist $plistBuddy -c "Set :CFBundleIdentifier $product\_bundleIdentifier" $buildPlist $plistBuddy -c "Set :env $product\_env" $buildPlist fi 使用方法：进入update_plist所在目录./update_plist [工程名称] [test或product] 至此环境切换就一劳永逸，相当方便了！ 三、自动化打包脚本脚本如下，如:distribute分发脚本 #!/bin/bash # $1 = xxxx 项目名 \# $2 = Debug/Release 模式 # $3 = test 环境名 targetName=$1 projectHome=`pwd` configuration=$2 \#env=$3 #日期 currentTime=`date '+%Y-%m-%d-%H-%M'` #auto increase build no CFBundleVersion自动加1 # plist文件所在路径 buildPlist=$projectHome/$targetName/Info.plist echo $buildPlist plistBuddy=/usr/libexec/PlistBuddy CFBundleVersion=$($plistBuddy -c "Print CFBundleVersion" $buildPlist) CFBundleVersion=$(($CFBundleVersion+1)) $plistBuddy -c "Set :CFBundleVersion $CFBundleVersion" $buildPlist \#build文件夹路径 build_path=$projectHome/build #定义ipa文件的路径 ipaFilePath=$projectHome/target/"$targetName"_build_"$CFBundleVersion" \#清理环境 xcodebuild clean -configuration $configuration #clean project rm -rf target/*.ipa rm -rf build/$configuration-iphoneos/*.app echo '///--------' echo '/// 清理完成' echo '///--------' echo '' \#更新plist中的属性值 ./update_plist $targetName product #编译并打包ipa文件 xcodebuild archive \ -workspace ${targetName}.xcworkspace \ -scheme ${targetName} \ -archivePath ${build_path}/${targetName}.xcarchive -quiet || exit echo '///--------' echo '/// 编译完成' echo '///--------' echo '' # 导出ipa包 xcodebuild -exportArchive \ -archivePath "${build_path}/${targetName}.xcarchive" \ -exportPath ${ipaFilePath} \ -exportOptionsPlist ${buildPlist} \ -quiet || exit if [ -e $ipaFilePath/$targetName.ipa ]; then echo '///----------' echo '/// ipa包已导出' echo '///----------' open $ipaFilePath else echo '///-------------' echo '/// ipa包导出失败 ' echo '///-------------' fi echo '///------------' echo '/// 打包ipa完成 ' echo '///-----------=' echo '' 使用方法：进入distribute所在目录./distribute [工程名称] [Debug或Release] 打包完成啦！😆🙃—–接下来会介绍和Jenkins结合使用——]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS获取设备信息汇总]]></title>
    <url>%2F2018%2F01%2F25%2FiOS%E8%8E%B7%E5%8F%96%E8%AE%BE%E5%A4%87%E4%BF%A1%E6%81%AF%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[关于获取iPhone手机设备信息的汇总： 屏幕宽度 屏幕高度 获取设备分辨率 获取设备版本号 获取iPhone名称 获取app版本号 获取电池电量 当前系统名称 当前系统版本号 通用唯一识别码UUID 获取当前设备IP 获取总内存大小 获取当前可用内存 获取精准电池电量 获取电池当前的状态，共有4种状态 获取当前语言 获取设备IDFA (Appstore禁止不使用广告而采集IDFA的app上架) 获取设备IDFV (iOS6及以上系统) 获取设备IMEI (iOS 5 以后不能获取！！！) IMEI(International Mobile Equipment Identity)是国际移动设备身份码的缩写，国际移动装备辨识码,通过苹果私有API获取IMEI号，上架苹果商店会被拒掉的 获取设备MAC (iOS 7 之后无法获取！！！) 获取设备UUID 获取设备UDID (审核会被拒的！！！) 具体代码实现： 屏幕宽度 + (CGFloat)getDeviceScreenWidth { return [UIScreen mainScreen].bounds.size.width; } 屏幕高度 + (CGFloat)getDeviceScreenHeight { return [UIScreen mainScreen].bounds.size.height; } 分辨率 + (NSString *)getDevice_Resolution{ return [NSString stringWithFormat:@"%.0fx%.0f",([NNDeviceInformation getDeviceScreenWidth]*[UIScreen mainScreen].scale),([NNDeviceInformation getDeviceScreenHeight]*[UIScreen mainScreen].scale)]; } 获取设备版本号 ,需要 #import &quot;sys/utsname.h&quot; //NSASCIIStringEncoding + (NSString *)getDeviceName { struct utsname systemInfo; uname(&systemInfo); NSString * platform = [NSString stringWithCString:systemInfo.machine encoding:NSUTF8StringEncoding]; if([platform isEqualToString:@"iPhone1,1"]) return@"iPhone 2G"; if([platform isEqualToString:@"iPhone1,2"]) return@"iPhone 3G"; if([platform isEqualToString:@"iPhone2,1"]) return@"iPhone 3GS"; if([platform isEqualToString:@"iPhone3,1"]) return@"iPhone 4"; if([platform isEqualToString:@"iPhone3,2"]) return@"iPhone 4"; if([platform isEqualToString:@"iPhone3,3"]) return@"iPhone 4"; if([platform isEqualToString:@"iPhone4,1"]) return@"iPhone 4S"; if([platform isEqualToString:@"iPhone5,1"]) return@"iPhone 5"; if([platform isEqualToString:@"iPhone5,2"]) return@"iPhone 5"; if([platform isEqualToString:@"iPhone5,3"]) return@"iPhone 5c"; if([platform isEqualToString:@"iPhone5,4"]) return@"iPhone 5c"; if([platform isEqualToString:@"iPhone6,1"]) return@"iPhone 5s"; if([platform isEqualToString:@"iPhone6,2"]) return@"iPhone 5s"; if([platform isEqualToString:@"iPhone7,1"]) return@"iPhone 6 Plus"; if([platform isEqualToString:@"iPhone7,2"]) return@"iPhone 6"; if([platform isEqualToString:@"iPhone8,1"]) return@"iPhone 6s"; if([platform isEqualToString:@"iPhone8,2"]) return@"iPhone 6s Plus"; if([platform isEqualToString:@"iPhone8,4"]) return@"iPhone SE"; if([platform isEqualToString:@"iPhone9,1"]) return@"iPhone 7"; if([platform isEqualToString:@"iPhone9,3"]) return@"iPhone 7"; if([platform isEqualToString:@"iPhone9,2"]) return@"iPhone 7 Plus"; if([platform isEqualToString:@"iPhone9,4"]) return@"iPhone 7 Plus"; if([platform isEqualToString:@"iPhone10,1"]) return@"iPhone 8"; if([platform isEqualToString:@"iPhone10,4"]) return@"iPhone 8"; if([platform isEqualToString:@"iPhone10,2"]) return@"iPhone 8 Plus"; if([platform isEqualToString:@"iPhone10,5"]) return@"iPhone 8 Plus"; if([platform isEqualToString:@"iPhone10,3"]) return@"iPhone X"; if([platform isEqualToString:@"iPhone10,6"]) return@"iPhone X"; if([platform isEqualToString:@"iPod1,1"]) return@"iPod Touch 1G"; if([platform isEqualToString:@"iPod2,1"]) return@"iPod Touch 2G"; if([platform isEqualToString:@"iPod3,1"]) return@"iPod Touch 3G"; if([platform isEqualToString:@"iPod4,1"]) return@"iPod Touch 4G"; if([platform isEqualToString:@"iPod5,1"]) return@"iPod Touch 5G"; if([platform isEqualToString:@"iPad1,1"]) return@"iPad 1G"; if([platform isEqualToString:@"iPad2,1"]) return@"iPad 2"; if([platform isEqualToString:@"iPad2,2"]) return@"iPad 2"; if([platform isEqualToString:@"iPad2,3"]) return@"iPad 2"; if([platform isEqualToString:@"iPad2,4"]) return@"iPad 2"; if([platform isEqualToString:@"iPad2,5"]) return@"iPad Mini 1G"; if([platform isEqualToString:@"iPad2,6"]) return@"iPad Mini 1G"; if([platform isEqualToString:@"iPad2,7"]) return@"iPad Mini 1G"; if([platform isEqualToString:@"iPad3,1"]) return@"iPad 3"; if([platform isEqualToString:@"iPad3,2"]) return@"iPad 3"; if([platform isEqualToString:@"iPad3,3"]) return@"iPad 3"; if([platform isEqualToString:@"iPad3,4"]) return@"iPad 4"; if([platform isEqualToString:@"iPad3,5"]) return@"iPad 4"; if([platform isEqualToString:@"iPad3,6"]) return@"iPad 4"; if([platform isEqualToString:@"iPad4,1"]) return@"iPad Air"; if([platform isEqualToString:@"iPad4,2"]) return@"iPad Air"; if([platform isEqualToString:@"iPad4,3"]) return@"iPad Air"; if([platform isEqualToString:@"iPad4,4"]) return@"iPad Mini 2G"; if([platform isEqualToString:@"iPad4,5"]) return@"iPad Mini 2G"; if([platform isEqualToString:@"iPad4,6"]) return@"iPad Mini 2G"; if([platform isEqualToString:@"iPad4,7"]) return@"iPad Mini 3"; if([platform isEqualToString:@"iPad4,8"]) return@"iPad Mini 3"; if([platform isEqualToString:@"iPad4,9"]) return@"iPad Mini 3"; if([platform isEqualToString:@"iPad5,1"]) return@"iPad Mini 4"; if([platform isEqualToString:@"iPad5,2"]) return@"iPad Mini 4"; if([platform isEqualToString:@"iPad5,3"]) return@"iPad Air 2"; if([platform isEqualToString:@"iPad5,4"]) return@"iPad Air 2"; if([platform isEqualToString:@"iPad6,3"]) return@"iPad Pro 9.7"; if([platform isEqualToString:@"iPad6,4"]) return@"iPad Pro 9.7"; if([platform isEqualToString:@"iPad6,7"]) return@"iPad Pro 12.9"; if([platform isEqualToString:@"iPad6,8"]) return@"iPad Pro 12.9"; if([platform isEqualToString:@"i386"]) return@"iPhone Simulator"; if([platform isEqualToString:@"x86_64"]) return@"iPhone Simulator"; return platform; } 获取iPhone名称 + (NSString *)getiPhoneName { return [UIDevice currentDevice].name; } 获取app版本号 + (NSString *)getAPPVerion { return [[[NSBundle mainBundle] infoDictionary] objectForKey:@"CFBundleShortVersionString"]; } 获取电池电量 + (CGFloat)getBatteryLevel { return [UIDevice currentDevice].batteryLevel; } 当前系统名称 + (NSString *)getSystemName { return [UIDevice currentDevice].systemName; } 当前系统版本号 + (NSString *)getSystemVersion { return [UIDevice currentDevice].systemVersion; } 通用唯一识别码UUID + (NSString *)getUUID { return [[UIDevice currentDevice] identifierForVendor].UUIDString; } 只能获取当前设备WIFI下网络下的IP #import &lt;ifaddrs.h&gt;#import &lt;arpa/inet.h&gt; + (NSString *)getDeviceIPAdress { NSString *address = @"an error occurred when obtaining ip address"; struct ifaddrs *interfaces = NULL; struct ifaddrs *temp_addr = NULL; int success = 0; success = getifaddrs(&interfaces); if (success == 0) { // 0 表示获取成功 temp_addr = interfaces; while (temp_addr != NULL) { if( temp_addr->ifa_addr->sa_family == AF_INET) { // Check if interface is en0 which is the wifi connection on the iPhone if ([[NSString stringWithUTF8String:temp_addr->ifa_name] isEqualToString:@"en0"]) { // Get NSString from C String address = [NSString stringWithUTF8String:inet_ntoa(((struct sockaddr_in *)temp_addr->ifa_addr)->sin_addr)]; } } temp_addr = temp_addr->ifa_next; } } freeifaddrs(interfaces); return address; } //可获取WiFi及蜂窝网络的IP，需要导入 #import &lt;ifaddrs.h&gt;#import &lt;arpa/inet.h&gt;#import &lt;net/if.h&gt;#define IOS_CELLULAR @&quot;pdp_ip0&quot;#define IOS_WIFI @&quot;en0&quot;#define IOS_VPN @&quot;utun0&quot;#define IP_ADDR_IPv4 @&quot;ipv4&quot;#define IP_ADDR_IPv6 @&quot;ipv6&quot; + (NSString *)getIPAddress:(BOOL)preferIPv4 { NSArray *searchArray = preferIPv4 ? @[ IOS_VPN @"/" IP_ADDR_IPv4, IOS_VPN @"/" IP_ADDR_IPv6, IOS_WIFI @"/" IP_ADDR_IPv4, IOS_WIFI @"/" IP_ADDR_IPv6, IOS_CELLULAR @"/" IP_ADDR_IPv4, IOS_CELLULAR @"/" IP_ADDR_IPv6 ] : @[ IOS_VPN @"/" IP_ADDR_IPv6, IOS_VPN @"/" IP_ADDR_IPv4, IOS_WIFI @"/" IP_ADDR_IPv6, IOS_WIFI @"/" IP_ADDR_IPv4, IOS_CELLULAR @"/" IP_ADDR_IPv6, IOS_CELLULAR @"/" IP_ADDR_IPv4 ] ; NSDictionary *addresses = [self getIPAddresses]; NSLog(@"addresses: %@", addresses); __block NSString *address; [searchArray enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) { address = addresses[obj]; //筛选出IP地址格式 if([self isValidatIP:address]) *stop = YES; }]; return address ? address : @"0.0.0.0"; } + (BOOL)isValidatIP:(NSString *)ipAddress { if (ipAddress.length == 0) { return NO; } NSString *urlRegEx = @"^([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\." "([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\." "([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\." "([01]?\\d\\d?|2[0-4]\\d|25[0-5])$"; NSError *error; NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:urlRegEx options:0 error:&error]; if (regex != nil) { NSTextCheckingResult *firstMatch=[regex firstMatchInString:ipAddress options:0 range:NSMakeRange(0, [ipAddress length])]; if (firstMatch) { NSRange resultRange = [firstMatch rangeAtIndex:0]; NSString *result=[ipAddress substringWithRange:resultRange]; //输出结果 NSLog(@"%@",result); return YES; } } return NO; } + (NSDictionary *)getIPAddresses { NSMutableDictionary *addresses = [NSMutableDictionary dictionaryWithCapacity:8]; // retrieve the current interfaces - returns 0 on success struct ifaddrs *interfaces; if(!getifaddrs(&interfaces)) { // Loop through linked list of interfaces struct ifaddrs *interface; for(interface=interfaces; interface; interface=interface->ifa_next) { if(!(interface->ifa_flags & IFF_UP) /* || (interface->ifa_flags & IFF_LOOPBACK) */ ) { continue; // deeply nested code harder to read } const struct sockaddr_in *addr = (const struct sockaddr_in*)interface->ifa_addr; char addrBuf[ MAX(INET_ADDRSTRLEN, INET6_ADDRSTRLEN) ]; if(addr && (addr->sin_family==AF_INET || addr->sin_family==AF_INET6)) { NSString *name = [NSString stringWithUTF8String:interface->ifa_name]; NSString *type; if(addr->sin_family == AF_INET) { if(inet_ntop(AF_INET, &addr->sin_addr, addrBuf, INET_ADDRSTRLEN)) { type = IP_ADDR_IPv4; } } else { const struct sockaddr_in6 *addr6 = (const struct sockaddr_in6*)interface->ifa_addr; if(inet_ntop(AF_INET6, &addr6->sin6_addr, addrBuf, INET6_ADDRSTRLEN)) { type = IP_ADDR_IPv6; } } if(type) { NSString *key = [NSString stringWithFormat:@"%@/%@", name, type]; addresses[key] = [NSString stringWithUTF8String:addrBuf]; } } } // Free memory freeifaddrs(interfaces); } return [addresses count] ? addresses : nil; } 获取总内存大小 + (long long)getTotalMemorySize { return [NSProcessInfo processInfo].physicalMemory; } 获取当前可用内存 + (long long)getAvailableMemorySize { vm_statistics_data_t vmStats; mach_msg_type_number_t infoCount = HOST_VM_INFO_COUNT; kern_return_t kernReturn = host_statistics(mach_host_self(), HOST_VM_INFO, (host_info_t)&vmStats, &infoCount); if (kernReturn != KERN_SUCCESS) { return NSNotFound; } return ((vm_page_size * vmStats.free_count + vm_page_size * vmStats.inactive_count)); } 获取电池当前的状态，共有4种状态 + (NSString *) getBatteryState { UIDevice *device = [UIDevice currentDevice]; if (device.batteryState == UIDeviceBatteryStateUnknown) { return @"UnKnow"; } else if (device.batteryState == UIDeviceBatteryStateUnplugged){ return @"Unplugged"; } else if (device.batteryState == UIDeviceBatteryStateCharging){ return @"Charging"; } else if (device.batteryState == UIDeviceBatteryStateFull){ return @"Full"; } return nil; } 获取当前语言 + (NSString *)getDeviceLanguage { NSArray *languageArray = [NSLocale preferredLanguages]; return [languageArray objectAtIndex:0]; } 获取设备IDFA +(NSString *)dy_getDeviceIDFA{ ASIdentifierManager *asIM = [[ASIdentifierManager alloc] init]; NSString *idfaStr = [asIM.advertisingIdentifier UUIDString]; DYLog(@"idfaStr------》%@",idfaStr); return idfaStr; } 获取设备IDFV +(NSString *)dy_getDeviceIDFV{ NSString* idfvStr = [[UIDevice currentDevice] identifierForVendor].UUIDString; DYLog(@"idfvStr------》%@",idfvStr); return idfvStr; } 获取设备IMEI +(NSString *)dy_getDeviceIMEI{ return @"iOS5以后不能获取手机IMEI"; } 获取设备MAC iOS7以后苹果对于sysctl和ioctl进行了技术处理，MAC地址返回的都是02:00:00:00:00:00 ,官方文档上这样写的“Twolow-level networking APIs that used to return a MAC address now return thefixed value 02:00:00:00:00:00. The APIs in question are sysctl(NET_RT_IFLIST) and ioctl(SIOCGIFCONF). Developers using the value of the MAC address should migrate toidentifiers such as -[UIDevice identifierForVendor].This change affects all apps running on iOS 7”。所以在iOS7以后想要获取设备的唯一标示Mac地址已经不行了，只能用其他的代替。 +(NSString*)dy_getDeviceMAC{ // ios7 之前获取的方法 int mib[6]; size_t len; char *buf; unsigned char *ptr; struct if_msghdr *ifm; struct sockaddr_dl *sdl; mib[0] = CTL_NET; mib[1] = AF_ROUTE; mib[2] = 0; mib[3] = AF_LINK; mib[4] = NET_RT_IFLIST; if ((mib[5] = if_nametoindex("en0")) == 0) { printf("Error: if_nametoindex error\n"); return NULL; } if (sysctl(mib, 6, NULL, &len, NULL, 0) < 0) { printf("Error: sysctl, take 1\n"); return NULL; } if ((buf = malloc(len)) == NULL) { printf("Could not allocate memory. error!\n"); return NULL; } if (sysctl(mib, 6, buf, &len, NULL, 0) < 0) { printf("Error: sysctl, take 2"); free(buf); return NULL; } ifm = (struct if_msghdr *)buf; sdl = (struct sockaddr_dl *)(ifm + 1); ptr = (unsigned char *)LLADDR(sdl); NSString *macStr = [NSString stringWithFormat:@"%02X:%02X:%02X:%02X:%02X:%02X",*ptr, *(ptr+1), *(ptr+2), *(ptr+3), *(ptr+4), *(ptr+5)]; free(buf); DYLog(@"macStr------》%@",macStr); return @"iOS7之后已无法获取！"; } 获取设备UUID +(NSString*)dy_getDeviceUUID{ CFUUIDRef uuid = CFUUIDCreate(NULL); assert(uuid != NULL); CFStringRef uuidStr = CFUUIDCreateString(NULL, uuid); DYLog(@"uuidStr------》%@",uuidStr); return (__bridge NSString *)(uuidStr); } 获取设备UDID no way，UDID是肯定要被苹果拒绝的，炸了！Stack Overflow提供了另外一种方法，越狱可尝试：stackoverflow +(NSString*)dy_getDeviceUDID{ return @"审核会被拒！！！！"; } 获取精准电池电量 123456789101112131415161718192021222324+ (CGFloat)getCurrentBatteryLevel &#123; UIApplication *app = [UIApplication sharedApplication]; if (app.applicationState == UIApplicationStateActive||app.applicationState==UIApplicationStateInactive)&#123; Ivar ivar= class_getInstanceVariable([app class],&quot;_statusBar&quot;); id status = object_getIvar(app, ivar); for (id aview in [status subviews])&#123; int batteryLevel = 0; for (id bview in [aview subviews])&#123; if ([NSStringFromClass([bview class]) caseInsensitiveCompare:@&quot;UIStatusBarBatteryItemView&quot;] == NSOrderedSame&amp;&amp;[[[UIDevice currentDevice] systemVersion] floatValue] &gt;=6.0)&#123; Ivar ivar= class_getInstanceVariable([bview class],&quot;_capacity&quot;); if(ivar)&#123; batteryLevel = ((int (*)(id, Ivar))object_getIvar)(bview, ivar); if (batteryLevel &gt; 0 &amp;&amp; batteryLevel &lt;= 100)&#123; return batteryLevel; &#125;else&#123; return 0; &#125; &#125; &#125; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Objective-C与Swift混编的那些事儿]]></title>
    <url>%2F2018%2F01%2F24%2F%E5%85%B3%E4%BA%8EObjective-C%E4%B8%8ESwift%E6%B7%B7%E7%BC%96%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%2F</url>
    <content type="text"><![CDATA[新建OC或者swift工程，在OC工程创建swift类或者在swift工程里创建OC类，Xcode会提示创建bridging桥接文件xxxx-Bridging-Header.h,其中xxxx为工程名称，如： 先以OC调用swift为例：首先在OC中需要调用Swift类的OC类中导入#import &quot;xxxx-Swift.h&quot;,其中xxxx为项目名称,此时直接调用swift类可能不会提示，我们需要做的就是先编译一下工程，应该就可以了，就是这么神奇！ 下面先介绍下OC中调用swift类的枚举:如：swift类中枚举若是这样写： enum TestType{ case Scale case Rotate}对于swift之间的调用是木有问题的，但是若要OC来调用，就需要修改一下书写方法了！修改如下： @objc public enum TestType: Int { case Scale case Rotate}这样关于枚举的调用就👌了！ Swift调用OC类Swift调用OC类，首先要在桥接文件xxxx-Bridging-Header.h中将要调用的OC类引入，如swift要使用ViewController类，则在桥接文件中导入#import &quot;ViewController.h&quot;即可]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS简单倒计时动画]]></title>
    <url>%2F2018%2F01%2F24%2FiOS%E7%AE%80%E5%8D%95%E5%80%92%E8%AE%A1%E6%97%B6%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[本文介绍两种简单的倒计时动画方式： swift版本： 新建CountDownLabel类继承UILabel，依次实现如下方法： var count: Int = 0 var timer = Timer.init() func startCount(){ self.initTimer() } func initTimer(){ if self.count == 0 { self.count = 5 } timer = Timer.scheduledTimer(timeInterval: 1, target: self, selector: #selector(countDown), userInfo: nil, repeats: true) } func countDown(){ if count > 0 { self.text = String.init(format: "%d", count) let anima2 = CAKeyframeAnimation.init(keyPath: "transform.scale") anima2.values = [NSNumber.init(value: 3.0),NSNumber.init(value: 2.0),NSNumber.init(value: 0.7),NSNumber.init(value: 1.0)] anima2.duration = 0.5 self.layer.add(anima2, forKey: "scalsTime") count -= 1 } else { timer.invalidate() self.removeFromSuperview() } } objective-c版本 开始倒计时 123456789101112131415161718192021222324- (void)startTime&#123;__block int timeout = 5;dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_source_t _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0,queue); dispatch_source_set_timer(_timer,dispatch_walltime(NULL, 0),1.0*NSEC_PER_SEC, 0);dispatch_source_set_event_handler(_timer, ^&#123; if ( timeout &lt;= 0 ) &#123; dispatch_source_cancel(_timer); dispatch_async(dispatch_get_main_queue(), ^&#123; [self beginRain]; &#125;); &#125; else &#123; int seconds = timeout % 6; dispatch_async(dispatch_get_main_queue(), ^&#123; [self countDown:seconds]; &#125;); timeout--; &#125; &#125;); dispatch_resume(_timer);&#125; 倒计时显示 12345678910111213141516171819202122-(void)countDown:(int)count&#123; if(count &lt;=0)&#123; //倒计时已到，作需要作的事吧。 return; &#125; UILabel* lblCountDown = [[UILabel alloc] initWithFrame:CGRectMake(0, 0, 100, 100)]; lblCountDown.textColor = [UIColor whiteColor]; lblCountDown.font = [UIFont boldSystemFontOfSize:80]; lblCountDown.textAlignment = NSTextAlignmentCenter; lblCountDown.center = self.view.center; lblCountDown.backgroundColor = [UIColor clearColor]; lblCountDown.text = [NSString stringWithFormat:@&quot;%d&quot;,count]; [self.view addSubview:lblCountDown]; [UIView animateWithDuration:1 delay:0 options:UIViewAnimationOptionCurveEaseOut animations:^&#123; lblCountDown.alpha = 0; lblCountDown.transform = CGAffineTransformScale(CGAffineTransformIdentity, 0.5, 0.5); &#125; completion:^(BOOL finished) &#123; [lblCountDown removeFromSuperview]; //不用GCD可直接用递归调用，直到计时为零 //[self countDown:count-1]; &#125;];&#125;]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS启动页渐消效果]]></title>
    <url>%2F2018%2F01%2F08%2FiOS%E5%90%AF%E5%8A%A8%E9%A1%B5%E6%B8%90%E6%B6%88%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[如何实现launchImage的渐渐消失效果！ 首先给UIView创建类别：UIView (AnimationProperty) .h中添加属性 /** * CGAffineTransformMakeScale */ @property (nonatomic) CGFloat scale; /** * CGAffineTransformMakeRotation */ @property (nonatomic) CGFloat angle; .m中利用runtime实现 NSString * const _recognizerScale = @"_recognizerScale"; - (void)setScale:(CGFloat)scale { objc_setAssociatedObject(self, (__bridge const void *)(_recognizerScale), @(scale), OBJC_ASSOCIATION_RETAIN_NONATOMIC); self.transform = CGAffineTransformMakeScale(scale, scale); } - (CGFloat)scale { NSNumber *scaleValue = objc_getAssociatedObject(self, (__bridge const void *)(_recognizerScale)); return scaleValue.floatValue; } NSString * const _recognizerAngle = @"_recognizerAngle"; - (void)setAngle:(CGFloat)angle { objc_setAssociatedObject(self, (__bridge const void *)(_recognizerAngle), @(angle), OBJC_ASSOCIATION_RETAIN_NONATOMIC); self.transform = CGAffineTransformMakeRotation(angle); } - (CGFloat)angle { NSNumber *angleValue = objc_getAssociatedObject(self, (__bridge const void *)(_recognizerAngle)); return angleValue.floatValue; } 在RootController中调用: NSLog(@"-------------YBUtils.launchImage------------%@",YBUtils.launchImage); // LaunchImage UIImageView *iconImageView = [[UIImageView alloc] initWithFrame:self.view.bounds]; iconImageView.image = YBUtils.launchImage; [self.view addSubview:iconImageView]; // Do animation [UIView animateKeyframesWithDuration:0.5f delay:0.5f options:0 animations:^{ iconImageView.scale = 1.2f; iconImageView.alpha = 0.f; } completion:^(BOOL finished) { [iconImageView removeFromSuperview]; }];]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Runtime知识总结]]></title>
    <url>%2F2017%2F12%2F28%2FRuntime%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Objective-C 扩展了 C 语言，并加入了面向对象特性和 Smalltalk 式的消息传递机制。而这个扩展的核心是一个用 C 和 编译语言 写的 Runtime 库。它是 Objective-C 面向对象和动态机制的基石。Objective-C 是一个动态语言，这意味着它不仅需要一个编译器，也需要一个运行时系统来动态得创建类和对象、进行消息传递和转发。理解 Objective-C 的 Runtime 机制可以帮我们更好的了解这个语言，适当的时候还能对语言进行扩展，从系统层面解决项目中的一些设计或技术问题。了解 Runtime ，要先了解它的核心 - 消息传递 （Messaging） 持续更新中 首先引入#import &lt;objc/runtime.h&gt; 获取类中的所有成员变量class_copyIvarList unsigned int count; //获取类中的所有成员变量 Ivar *ivarList = class_copyIvarList(self, &count); for (NSInteger i = 0; i < count; i ++) { Ivar ivar = ivarList[i]; //获得成员属性名 NSString *name = [NSString stringWithUTF8String:ivar_getName(ivar)]; NSLog(@">>>>>propertyofSelf>>name>>>>>>%@",name); } eg:获取UILabel类的实例变量列表 - (NSArray *)ivarArray:(Class)cls { unsigned int count = 0; Ivar *ivarsA = class_copyIvarList(cls, &count); NSMutableArray *arr = [[NSMutableArray alloc] initWithCapacity:count]; for (int i = 0;i < count; i++) { Ivar iv = ivarsA[i]; NSString *ivarName = [NSString stringWithUTF8String:ivar_getName(iv)]; [arr addObject:ivarName]; } free(ivarsA); return arr; } 结果： ( "_size", "_highlightedColor", "_numberOfLines", "_measuredNumberOfLines", "_baselineReferenceBounds", "_lastLineBaseline", "_previousBaselineOffsetFromBottom", "_firstLineBaseline", "_previousFirstLineBaseline", "_minimumScaleFactor", "_content", "_synthesizedAttributedText", "_defaultAttributes", "_fallbackColorsForUserInterfaceStyle", "_minimumFontSize", "_lineSpacing", "_layout", "_scaledMetrics", "_cachedIntrinsicContentSize", "_contentsFormat", "_cuiCatalog", "_cuiStyleEffectConfiguration", "_textLabelFlags", "_adjustsFontForContentSizeCategory", "__textColorFollowsTintColor", "_preferredMaxLayoutWidth", "_multilineContextWidth", "__visualStyle" ) 但是跳转到UILabel.h，你会发现里面有好多的属性不包含在我们根据该方法得出的属性数组里面，而且使用该方法得到的属性在UILabel.h里面并没有。这个是什么原因呢？先看一下好多UILabel里面的属性没有在数组里面打印问题：猜想应该是在UILabel.m里面使用了@dynamic。导致没有自动生成getter、setter和ivar，所以没有在数组里面包含。 @synthsize：如果没有手动实现setter/getter方法那么会自动生成，自动生成var变量。如果不写，默认生成getter/setter和var。你也可以使用该关键字自己设置自动变量的名称。@dynamic告诉编译器：属性的setter/getter需要用户自己实现，不自动生成，而且也不会产生_var变量。 也就是说在UILabel里面虽然有个text的属性，也许在UILabel.m里面已经包含： @dynamic text; 这样的话在实现里面没有产生实例变量，只是手动实现了getter和setter，所以就不会显示text属性在刚才得到的数组里面了。至于数组中有UILabel.h里面没有的变量，这个就好理解了，有可能在UILabel.m里面添加了一些实例变量或者在运行时添加了这些实例变量。 除此方法之外，你还可以使用class_copyPropertyList方法，这个是拿到的所有用 @property声明的属性,包括在.m里面添加的属性（所以打印出来的可能要比真实在.h里面看到的多），具体实现和上面的获取方法类似： - (NSArray *)propertyArr:(Class)cls { unsigned count = 0; objc_property_t *properties = class_copyPropertyList(cls, &count); if (count == 0) { return nil; } NSMutableArray *arr = [[NSMutableArray alloc] initWithCapacity:count]; for (int i = 0; i < count; i ++) { objc_property_t property = properties[i]; NSString *propertyName = [NSString stringWithUTF8String:property_getName(property)] ; [arr addObject:propertyName]; } free(properties); return arr; } 结果 ( hash, superclass, description, debugDescription, "ab_text", "ab_textAttributes", "_capOffsetFromBoundsTop", "_firstLineBaselineOffsetFromBoundsTop", "_firstLineCapFrameOriginY", "_firstLineBaselineFrameOriginY", "_lastLineBaselineFrameOriginY", "_drawsDebugBaselines", "_wantsUnderlineForAccessibilityButtonShapesEnabled", hash, superclass, description, debugDescription, "_wantsUnderlineForAccessibilityButtonShapesEnabled", "_lastLineBaseline", lineSpacing, "_content", "_synthesizedAttributedText", "_textColorFollowsTintColor", "_visualStyle", text, font, textColor, shadowColor, shadowOffset, textAlignment, lineBreakMode, attributedText, highlightedTextColor, highlighted, userInteractionEnabled, enabled, numberOfLines, adjustsFontSizeToFitWidth, baselineAdjustment, minimumScaleFactor, allowsDefaultTighteningForTruncation, preferredMaxLayoutWidth, minimumFontSize, adjustsLetterSpacingToFitWidth, hash, superclass, description, debugDescription, adjustsFontForContentSizeCategory ) 获取类名class_getName(Class _Nullable cls) 入参:类Class 返回:类名char数组 NSLog(@"-------class_getInstanceSize---------%s", class_getName([self class])); 获取实例大小（返回size_t） 入参:实例的类Class 返回:大小size_t NSLog(@"-------class_getInstanceSize---------%zu",class_getInstanceSize([self class])); 获取类中指定名称实例成员变量的信息 入参:(类Class，变量名) 返回:变量信息Ivar 1.实例变量是指变量不是属性.例如某类有个属性为:username 那么它对应的实例变量为_username 2.这个方法可以获取属性的变量,也可以获取私有变量(这点很重要) 3.如果获取的变量为空,那么 ivar_getName和 ivar_getTypeEncoding 获取的值为空,那么[NSString stringWithUTF8String:ivar1Name] 执行崩溃 const char *result = [@"joy" UTF8String]; NSLog(@"-------class_getInstanceVariable---------%@",class_getInstanceVariable(self.class, result)); 获取方法实现class_getMethodImplementation或者class_getMethodImplementation_stret，但是后者not available in arm64 入参:(类Class，方法名SEL) 返回:方法实现IMP IMP result = class_getMethodImplementation([ViewController class], @selector(test)); result(); - (void)test{ NSLog(@"-----------获取方法实现--------"); } 获取类方法 入参:(类Class，方法名SEL) 返回:方法Method Method result = class_getClassMethod([SingleDog class], @selector(test)); NSLog(@">>>>>>>>%@", result); 获取父类class_getSuperclass 入参:类Class 返回:类Class Class current = self.class; id nw = class_getSuperclass(current); NSLog(@"---------当前-------%@",nw); 对象操作 关联对象 /** 关联 @param object#> 源对象 @param key#> 关键字 @param value#> 关联的对象 @param policy#> 关联策略 */ objc_setAssociatedObject(, , , ) 获取对象 /** 获取关联对象 @param object#> 被关联对象 @param key#> 关键字（属性） */ objc_getAssociatedObject(, ) 断开关联 /* 断开关联：直接传nil即可 */ objc_setAssociatedObject(array, &associatedKey, nil, OBJC_ASSOCIATION_RETAIN_NONATOMIC) eg:关联UIButton的选中状态 关联BOOL方法 需转NSNumber对象 - (void)protocolBtnClick:(UIButton *)sender{ sender.selected = !sender.selected; NSNumber *num = [NSNumber numberWithBool:sender.selected]; //关联选中状态 objc_setAssociatedObject(sender, @"protocolBtn", num, OBJC_ASSOCIATION_RETAIN_NONATOMIC); } //获取关联值 NSNumber *select = objc_getAssociatedObject(sender, @"protocolBtn"); NSLog(@"____________当前状态___________%d",[select boolValue]); 给category增加属性默认情况下category不能增加属性，只能添加方法。 eg: 定义类UserModel @interface UserModel : NSObject @property (nonatomic, strong) NSString *name; @property (nonatomic, strong) NSString *gender; @end 定义UserModel的category：UserModel (cate) eg : 想给category增加一个属性remark #import "UserModel.h" @interface UserModel (cate) @property (nonatomic, strong) NSString *remark; @end 这样直接增加是错误的，若要增加属性，可使用runtime来增加伪属性： #import "UserModel.h" @interface UserModel (cate) - (NSString *)remark; - (void)setRemark:(NSString *)remark; @end #import #import "UserModel+cate.h" @implementation UserModel (cate) /* * 使用关联对象模拟实例变量 * 使用objc_getAssociatedObject、objc_setAssociatedObject模拟『属性』的存取方法 */ - (NSString *)remark{ return objc_getAssociatedObject(self, _cmd); } - (void)setRemark:(NSString *)remark{ objc_setAssociatedObject(self, @selector(remark), remark, OBJC_ASSOCIATION_RETAIN_NONATOMIC); } @end 输出： UserModel *model = [[UserModel alloc] init]; model.name = @"xubojoy"; model.gender = @"男"; model.remark = @"hello world !!!!"; NSLog(@"-UserModel----%@--%@--%@",model.name,model.gender,model.remark); 字典转model的两种方式方式一：class_copyPropertyList + (instancetype)zg_modelFromDic:(NSDictionary *)dataDic { id model = [[self alloc] init]; unsigned int count = 0; objc_property_t *properties = class_copyPropertyList([self class], &count); if (count == 0) { return model; } for (int i = 0;i < count; i++) { objc_property_t property = properties[i]; NSString *propertyName = [NSString stringWithUTF8String:property_getName(property)]; id value = dataDic[propertyName]; [model setValue:value forKey:propertyName]; } free(properties); return model; } 方式二：class_copyIvarList + (instancetype)zg_modelFromDic:(NSDictionary *)dataDic { id model = [[self alloc] init]; unsigned int count = 0; Ivar *ivarsA = class_copyIvarList(self, &count); if (count == 0) { return model; } for (int i = 0;i < count; i++) { Ivar iv = ivarsA[i]; NSString *ivarName = [NSString stringWithUTF8String:ivar_getName(iv)]; ivarName = [ivarName substringFromIndex:1]; id value = dataDic[ivarName]; [model setValue:value forKey:ivarName]; } free(ivarsA); return model; } 获取指定的属性 入参:类Class，属性名char数组 返回:属性objc_property_t 1.属性不是变量,此方法只能获取属性 2.如果属性不存在那么返回的结构体为0(可以参考下面的判断) 3.属性不存在获取property_getName 和 property_getAttributes 会崩溃 跳转]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVN命令行操作]]></title>
    <url>%2F2017%2F12%2F28%2FSVN%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[从主干新建分支：svn cp [主干仓库地址] [分支地址] -m &quot;测试分支” eg: 克隆分支到本地 (svn checkout 简写 co):svn co [分支地址] 分支名 eg: 查看提交历史记录：svn log 或者 (svn log --stop-on-copy -q [分支地址]) 不同之处： 前者能够显示出历史提交的message信息 后者只能显示出提交的历史版本 更新：提交前养成更新的习惯，可尽量避免冲突 svn update 检查更改及冲突：svn status 如果有解决冲突，没有就svn commit命令就可以完成提交 添加更改文件 添加单个文件 svn add [文件] eg: $ svn add update_plist 添加批量文件 svn add * 提交：svn commit -m “更改说明&quot; 分支删除svn rm [分支地址] -m &quot;说明文字&quot; eg: 更改分支名svn move -m &#39;更改分支名&#39; [分支地址] [改名后的分支地址] eg: ———————–未完待续———————–]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[平安夜的生日礼物！]]></title>
    <url>%2F2017%2F12%2F24%2F%E5%B9%B3%E5%AE%89%E5%A4%9C%E7%9A%84%E7%94%9F%E6%97%A5%E7%A4%BC%E7%89%A9%EF%BC%81%2F</url>
    <content type="text"><![CDATA[生日与我来说，从来都是安静的过了，或许忙了自己也不会记得，然而今年的生日却被提前收到了生日礼物，还是在这个平安夜，某人整理了一些照片做成了一本相册寄了过来，有些照片连我自己都没有，还是很令人意外的，毕业三年多了，虽然这些都是学生时代的礼物方式，但还是有点儿surprise，毕竟自己是个很怀旧的人！ 封面 《致青春》]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[__block和__weak修饰符的区别]]></title>
    <url>%2F2017%2F12%2F24%2Fblock%E5%92%8C-weak%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[今儿要整理的是有关于__block和__weak知识点！ block下循环引用的问题 __block本身并不能避免循环引用，避免循环引用需要在block内部把__block修饰的obj置为nil __weak可以避免循环引用，但是其会导致外部对象释放了之后，block 内部也访问不到这个对象的问题，我们可以通过在 block 内部声明一个 __strong的变量来指向 weakObj，使外部对象既能在 block 内部保持住，又能避免循环引用的问题 __block与__weak功能上的区别。 __block会持有该对象，即使超出了该对象的作用域，该对象还是会存在的，直到block对象从堆上销毁；而__weak仅仅是将该对象赋值给weak对象，当该对象销毁时，weak对象将指向nil； __block可以让block修改局部变量，而__weak不能。另外，MRC中__block是不会引起retain；但在ARC中__block则会引起retain。所以ARC中应该使用__weak。 因此，__block和__weak修饰符的区别其实是挺明显的： 1.__block不管是ARC还是MRC模式下都可以使用，可以修饰对象，还可以修饰基本数据类型。 2.__weak只能在ARC模式下使用，也只能修饰对象（NSString），不能修饰基本数据类型（int）。 3.__block对象可以在block中被重新赋值，__weak不可以。 4.__block对象在ARC下可能会导致循环引用，非ARC下会避免循环引用，__weak只在ARC下使用，可以避免循环引用。 Block外部使用： __weak typeof(self) weakSelf = self; Block内部使用： __strong typeof(weakSelf) strongSelf = weakSelf; 补充：block中为什么会用到weakself是因为要避免循环引用，一旦出现循环引用那么对象就会常驻内存。如果一个应用程序里面你有很多循环引用，那么内存占用就会比较大，这当然是谁都不想看到的结果。那么问题的重点就是：什么时候会出现循环引用？先来看一个例子： NSArray *anArray = @[@"1", @"2", @"3"]; [anArray enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) { [self doSomething:idx]; }]; 这种情况下，`block`中`retain`了`self`，当`block`中的代码被执行完后，`self`就会被`ARC`释放。所以不需要处理`weakself`的情况。 再来看一个例子： @interface ViewController () @property (nonatomic, strong) void(^Block)(id obj, NSUInteger idx, BOOL *stop); @end weak ViewController*weakSelf = self;self.Block = ^(id obj, NSUInteger idx, BOOL *stop) { [weakSelf doSomething:idx];}这个例子的区别在于：block被self strong引用。所以结果就是block中引用了self，self引用了block。那么这个时候，如果你不使用weakself，则self和block永远都不会被释放。那么是不是遇到block都要使用weakself呢？当然不是，而且如果全部使用weakself，会出现你想执行block中的代码时，self已经被释放掉了的情况。另外，在处理weakself时，有两种做法`weak和__unsafe_unretained`,两种做法各有推荐。]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 常用正则表达式(二)]]></title>
    <url>%2F2017%2F12%2F23%2FiOS-%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[匹配正则表达式的一些简单封装 - (BOOL)isValidateByRegex:(NSString *)regex { NSPredicate *pre = [NSPredicate predicateWithFormat:@"SELF MATCHES %@",regex]; return [pre evaluateWithObject:self]; } /** 是否能够匹配正则表达式 @param regex 正则表达式 @param options 普配方式. @return YES：如果可以匹配正则表达式; 否则,NO. */ - (BOOL)matchesRegex:(NSString *)regex options:(NSRegularExpressionOptions)options { NSRegularExpression *pattern = [NSRegularExpression regularExpressionWithPattern:regex options:options error:NULL]; if (!pattern) return NO; return ([pattern numberOfMatchesInString:self options:0 range:NSMakeRange(0, self.length)] > 0); } /** 匹配正则表达式，并使用匹配的每个对象执行给定的块。 @param regex 正则表达式 @param options 上报的匹配选项. @param block 应用于在数组元素中匹配的块. 该块需要四个参数: match: 匹配的子串. matchRange: 匹配选项. stop: 一个布尔值的引用。块可以设置YES来停止处理阵列。stop参数是一个唯一的输出。你应该给块设置YES。 */ - (void)enumerateRegexMatches:(NSString *)regex options:(NSRegularExpressionOptions)options usingBlock:(void (^)(NSString *match, NSRange matchRange, BOOLBOOL *stop))block { if (regex.length == 0 || !block) return; NSRegularExpression *pattern = [NSRegularExpression regularExpressionWithPattern:regex options:options error:nil]; if (!regex) return; [pattern enumerateMatchesInString:self options:kNilOptions range:NSMakeRange(0, self.length) usingBlock:^(NSTextCheckingResult *result, NSMatchingFlags flags, BOOLBOOL *stop) { block([self substringWithRange:result.range], result.range, stop); }]; } /** 返回一个包含匹配正则表达式的新字符串替换为模版字符串。 @param regex 正则表达式 @param options 上报的匹配选项. @param replacement 用来替换匹配到的内容. @return 返回一个用指定字符串替换匹配字符串后的字符串. */ - (NSString *)stringByReplacingRegex:(NSString *)regex options:(NSRegularExpressionOptions)options withString:(NSString *)replacement { NSRegularExpression *pattern = [NSRegularExpression regularExpressionWithPattern:regex options:options error:nil]; if (!pattern) return self; return [pattern stringByReplacingMatchesInString:self options:0 range:NSMakeRange(0, [self length]) withTemplate:replacement]; } 银行卡号有效性问题Luhn算法 /** 银行卡号有效性问题Luhn算法 * 现行 16 位银联卡现行卡号开头 6 位是 622126～622925 之间的，7 到 15 位是银行自定义的， * 可能是发卡分行，发卡网点，发卡序号，第 16 位是校验码。 * 16 位卡号校验位采用 Luhm 校验方法计算： * 1，将未带校验位的 15 位卡号从右依次编号 1 到 15，位于奇数位号上的数字乘以 2 * 2，将奇位乘积的个十位全部相加，再加上所有偶数位上的数字 * 3，将加法和加上校验位能被 10 整除。 */ - (BOOL)wl_bankCardluhmCheck{ NSString * lastNum = [[self substringFromIndex:(self.length-1)] copy];//取出最后一位 NSString * forwardNum = [[self substringToIndex:(self.length -1)] copy];//前15或18位 NSMutableArray * forwardArr = [[NSMutableArray alloc] initWithCapacity:0]; for (int i=0; i -1; i--) {//前15位或者前18位倒序存进数组 [forwardDescArr addObject:forwardArr[i]]; } NSMutableArray * arrOddNum = [[NSMutableArray alloc] initWithCapacity:0];//奇数位*2的积 < 9 NSMutableArray * arrOddNum2 = [[NSMutableArray alloc] initWithCapacity:0];//奇数位*2的积 > 9 NSMutableArray * arrEvenNum = [[NSMutableArray alloc] initWithCapacity:0];//偶数位数组 for (int i=0; i< forwardDescArr.count; i++) { NSInteger num = [forwardDescArr[i] intValue]; if (i%2) {//偶数位 [arrEvenNum addObject:[NSNumber numberWithInteger:num]]; }else{//奇数位 if (num * 2 < 9) { [arrOddNum addObject:[NSNumber numberWithInteger:num * 2]]; }else{ NSInteger decadeNum = (num * 2) / 10; NSInteger unitNum = (num * 2) % 10; [arrOddNum2 addObject:[NSNumber numberWithInteger:unitNum]]; [arrOddNum2 addObject:[NSNumber numberWithInteger:decadeNum]]; } } } __block NSInteger sumOddNumTotal = 0; [arrOddNum enumerateObjectsUsingBlock:^(NSNumber * obj, NSUInteger idx, BOOLBOOL *stop) { sumOddNumTotal += [obj integerValue]; }]; __block NSInteger sumOddNum2Total = 0; [arrOddNum2 enumerateObjectsUsingBlock:^(NSNumber * obj, NSUInteger idx, BOOLBOOL *stop) { sumOddNum2Total += [obj integerValue]; }]; __block NSInteger sumEvenNumTotal =0 ; [arrEvenNum enumerateObjectsUsingBlock:^(NSNumber * obj, NSUInteger idx, BOOLBOOL *stop) { sumEvenNumTotal += [obj integerValue]; }]; NSInteger lastNumber = [lastNum integerValue]; NSInteger luhmTotal = lastNumber + sumEvenNumTotal + sumOddNum2Total + sumOddNumTotal; return (luhmTotal%10 ==0)?YES:NO; }]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 常用正则表达式]]></title>
    <url>%2F2017%2F12%2F23%2FiOS-%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则的知识常常用到，有用的东西就要记录下来，现在做下整理！ /** * 正则表达式简单说明 * 语法： . 匹配除换行符以外的任意字符 \\w 匹配字母或数字或下划线或汉字 \\s 匹配任意的空白符 \\d 匹配数字 \\b 匹配单词的开始或结束 ^ 匹配字符串的开始 $ 匹配字符串的结束 * 重复零次或更多次 + 重复一次或更多次 ? 重复零次或一次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 \\W 匹配任意不是字母，数字，下划线，汉字的字符 \\S 匹配任意不是空白符的字符 \\D 匹配任意非数字的字符 \\B 匹配不是单词开头或结束的位置 [^x] 匹配除了x以外的任意字符 [^aeiou]匹配除了aeiou这几个字母以外的任意字符 *? 重复任意次，但尽可能少重复 +? 重复1次或更多次，但尽可能少重复 ?? 重复0次或1次，但尽可能少重复 {n,m}? 重复n到m次，但尽可能少重复 {n,}? 重复n次以上，但尽可能少重复 \\a 报警字符(打印它的效果是电脑嘀一声) \\b 通常是单词分界位置，但如果在字符类里使用代表退格 \\t 制表符，Tab \\r 回车 \\v 竖向制表符 \\f 换页符 \\n 换行符 \\e Escape \\0nn ASCII代码中八进制代码为nn的字符 \\xnn ASCII代码中十六进制代码为nn的字符 \\unnnn Unicode代码中十六进制代码为nnnn的字符 \\cN ASCII控制字符。比如\\cC代表Ctrl+C \\A 字符串开头(类似^，但不受处理多行选项的影响) \\Z 字符串结尾或行尾(不受处理多行选项的影响) \\z 字符串结尾(类似$，但不受处理多行选项的影响) \\G 当前搜索的开头 \\p{name} Unicode中命名为name的字符类，例如\\p{IsGreek} (?>exp) 贪婪子表达式 (?-exp) 平衡组 (?im-nsx:exp) 在子表达式exp中改变处理选项 (?im-nsx) 为表达式后面的部分改变处理选项 (?(exp)yes|no) 把exp当作零宽正向先行断言，如果在这个位置能匹配，使用yes作为此组的表达式；否则使用no (?(exp)yes) 同上，只是使用空表达式作为no (?(name)yes|no) 如果命名为name的组捕获到了内容，使用yes作为表达式；否则使用no (?(name)yes) 同上，只是使用空表达式作为no 捕获 (exp) 匹配exp,并捕获文本到自动命名的组里 (?exp) 匹配exp,并捕获文本到名称为name的组里，也可以写成(?'name'exp) (?:exp) 匹配exp,不捕获匹配的文本，也不给此分组分配组号 零宽断言 (?=exp) 匹配exp前面的位置 (?]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用ZipArchive对文件压缩]]></title>
    <url>%2F2017%2F12%2F20%2F%E4%BD%BF%E7%94%A8ZipArchive%E5%AF%B9%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9%2F</url>
    <content type="text"><![CDATA[首先引入第三方库 ZipArchive 导入头文件 #import &quot;ZipArchive.h&quot; - (void)zipFile{ NSString *docsPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject]; zipFilePath = [docsPath stringByAppendingPathComponent:@"testZipFile.zip"]; //实例化一个压缩文档，并创建文件 ZipArchive *za = [[ZipArchive alloc]init]; [za CreateZipFile2:zipFilePath]; NSDate *datenow = [NSDate date];//现在时间,你可以输出来看下是什么格式 NSInteger timeSp = [[NSNumber numberWithDouble:[datenow timeIntervalSince1970]] integerValue]; //进行图片压缩 UIImage * imageK = [UIImage imageNamed:@""]; NSData * imgData = UIImageJPEGRepresentation(imageK, 0.6); if([imageK isKindOfClass:[UIImage class]]) { [za addDataToZip:imgData fileAttributes:nil newname:[NSString stringWithFormat:@"%ld.png",(long)timeSp]]; } //关闭zip文件操作 BOOL success = [za CloseZipFile2]; if (success) { [self uploadZipData]; }else{ NSLog( @"压缩失败"); } } -(void)uploadZipData{ NSFileManager* fm = [NSFileManager defaultManager]; NSData* data = [[NSData alloc] init]; data = [fm contentsAtPath:zipFilePath]; NSLog(@"%@",[[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]); }]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS获取图片Color]]></title>
    <url>%2F2017%2F12%2F18%2FiOS%E8%8E%B7%E5%8F%96%E5%9B%BE%E7%89%87Color%2F</url>
    <content type="text"><![CDATA[本文介绍三种获取图片颜色方法： 1.获取图片某一点的颜色- (UIColor *)colorAtPixel:(CGPoint)point withImage:(UIImage *)image{ if (!CGRectContainsPoint(CGRectMake(0.0f, 0.0f, image.size.width, image.size.height), point)) { return nil; } NSInteger pointX = trunc(point.x); NSInteger pointY = trunc(point.y); CGImageRef cgImage = image.CGImage; NSUInteger width = image.size.width; NSUInteger height = image.size.height; CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB(); int bytesPerPixel = 4; int bytesPerRow = bytesPerPixel * 1; NSUInteger bitsPerComponent = 8; unsigned char pixelData[4] = { 0, 0, 0, 0 }; CGContextRef context = CGBitmapContextCreate(pixelData, 1, 1, bitsPerComponent, bytesPerRow, colorSpace, kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big); CGColorSpaceRelease(colorSpace); CGContextSetBlendMode(context, kCGBlendModeCopy); CGContextTranslateCTM(context, -pointX, pointY-(CGFloat)height); CGContextDrawImage(context, CGRectMake(0.0f, 0.0f, (CGFloat)width, (CGFloat)height), cgImage); CGContextRelease(context); CGFloat red = (CGFloat)pixelData[0] / 255.0f; CGFloat green = (CGFloat)pixelData[1] / 255.0f; CGFloat blue = (CGFloat)pixelData[2] / 255.0f; CGFloat alpha = (CGFloat)pixelData[3] / 255.0f; return [UIColor colorWithRed:red green:green blue:blue alpha:alpha]; } 2.获取图片的主色调- (UIColor*)mostColor:(UIImage*)image{ //#if __IPHONE_OS_VERSION_MAX_ALLOWED > __IPHONE_6_1 int bitmapInfo = kCGBitmapByteOrderDefault | kCGImageAlphaPremultipliedLast; //#else int bitmapInfo = kCGImageAlphaPremultipliedLast; //#endif //第一步 先把图片缩小 加快计算速度. 但越小结果误差可能越大 CGSize thumbSize=CGSizeMake(image.size.width/2, image.size.height/2); CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB(); CGContextRef context = CGBitmapContextCreate(NULL, thumbSize.width, thumbSize.height, 8,//bits per component thumbSize.width*4, colorSpace, bitmapInfo); CGRect drawRect = CGRectMake(0, 0, thumbSize.width, thumbSize.height); CGContextDrawImage(context, drawRect, image.CGImage); CGColorSpaceRelease(colorSpace); //第二步 取每个点的像素值 unsigned char* data = CGBitmapContextGetData (context); if (data == NULL) return nil; NSCountedSet *cls=[NSCountedSet setWithCapacity:thumbSize.width*thumbSize.height]; for (int x=0; x]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS多线程/串行/并行/同步/异步]]></title>
    <url>%2F2017%2F12%2F15%2FIOS%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%B2%E8%A1%8C-%E5%B9%B6%E8%A1%8C-%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[进程:正在进行中的程序被称为进程，负责程序运行的内存分配;每一个进程都有自己独立的虚拟内存空间； 线程:线程是进程中一个独立的执行路径(控制单元);一个进程中至少包含一条线程，即主线程。 队列：dispatch_queue_t，一种先进先出的数据结构，线程的创建和回收不需要程序员操作，由队列负责。 串行队列：队列中的任务只会顺序执行(类似跑步)dispatch_queue_t q = dispatch_queue_create(“....”, dispatch_queue_serial); 并行队列：队列中的任务通常会并发执行(类似赛跑)dispatch_queue_t q = dispatch_queue_create("......", dispatch_queue_concurrent); 全局队列：是系统开发的，直接拿过来（get）用就可以；与并行队列类似，但调试时，无法确认操作所在队列dispatch_queue_t q = dispatch_get_global_queue(dispatch_queue_priority_default, 0); 主队列：每一个应用程序对应唯一一个主队列，直接get即可；在多线程开发中，使用主队列更新UIdispatch_queue_t q = dispatch_get_main_queue(); 操作 dispatch_async 异步操作，会并发执行，无法确定任务的执行顺序； dispatch_sync 同步操作，会依次顺序执行，能够决定任务的执行顺序； 串行队列同步：操作不会新建线程、操作顺序执行；串行队列异步：操作需要一个子线程，会新建线程、线程的创建和回收不需要程序员参与，操作顺序执行，是最安全的选择； 并行队列同步：操作不会新建线程、操作顺序执行；并行队列异步：操作会新建多个线程（有多少任务，就开n个线程执行）、操作无序执行；队列前如果有其他任务，会等待前面的任务完成之后再执行；场景：既不影响主线程，又不需要顺序执行的操作！ 全局队列异步：操作会新建多个线程、操作无序执行，队列前如果有其他任务，会等待前面的任务完成之后再执行；全局队列同步：操作不会新建线程、操作顺序执行； 主队列异步：操作都应该在主线程上顺序执行的，不存在异步的；主队列同步：如果把主线程中的操作看成一个大的block，那么除非主线程被用户杀掉，否则永远不会结束；主队列中添加的同步操作永远不会被执行，会死锁； 不同队列嵌套dispathch_sync(同步)任务的结果 // 1.全局队列，都在主线程上执行，不会死锁 dispatch_queue_priority_default dispatch_queue_t q = dispatch_get_global_queue(dispatch_queue_priority_default, 0); // 2.并行队列，都在主线程上执行，不会死锁 dispatch_queue_concurrent dispatch_queue_t q = dispatch_queue_create(“cn.itcast.gcddemo”, dispatch_queue_concurrent); // 3.串行队列，会死锁，但是会执行嵌套同步操作之前的代码 dispatch_queue_serial dispatch_queue_t q = dispatch_queue_create(“cn.itcast.gcddemo”, dispatch_queue_serial); // 4.主队列，直接死锁 dispatch_get_main_queue() dispatch_queue_t q = dispatch_get_main_queue(); dispatch_sync同步应用开发场景,阻塞并行队列的执行，要求某一操作执行后再进行后续操作，如用户登录,确保块代码之外的局部变量确实被修改 __block BOOL login = NO; dispatch_queue_t concurrentQueue = dispatch_queue_create(“cn.xubojoy.gcdtest”, DISPATCH_QUEUE_CONCURRENT); dispatch_sync(concurrentQueue, ^{ NSLog(@”模拟耗时操作 %@”,[NSThread currentThread]); [NSThread sleepForTimeInterval:2.0]; NSLog(@”模拟耗时完成 %@”, [NSThread currentThread]); login = YES; }); dispatch_async(concurrentQueue, ^{ NSLog(@”登录完成的处理 %@”, [NSThread currentThread]); }); iOS三种多线程技术：1.NSThread (1)使用NSThread对象建立一个线程非常方便 (2)但是！要使用NSThread管理多个线程非常困难，不推荐使用 (3)技巧！使用[NSThread currentThread]跟踪任务所在线程，适用于这三种技术 2.NSOperation/NSOperationQueue (1)是使用GCD实现的一套objective-c的api (2)是面向对象的线程技术 (3)提供了一些在GCD中不容易实现的特性，如：限制最大并发数量、操作之间的依赖关系 3.GCD —— grand central dispatch (1)是基于c语言的底层api (2)用block定义任务，使用起来非常灵活便捷 (3)提供了更多的控制能力以及操作队列中所不能使用的底层函数 队列和线程的区别： 队列：是管理线程的，相当于线程池,能管理线程什么时候执行。 队列分为串行队列和并行队列: 串行队列：队列中的线程按顺序执行（不会同时执行） 并行队列：队列中的线程会并发执行，可能会有一个疑问，队列不是先进先出吗，如果后面的任务执行完了，怎么出去的了。这里需要强调下，任务执行完毕了，不一定出队列。只有前面的任务执行完了，才会出队列。 主线程队列和GCD创建的队列也是有区别的。 主线程队列和GCD创建的队列是不同的。在GCD中创建的队列优先级没有主队列高，所以在gcd中的串行队列开启同步任务里面没有嵌套任务是不会阻塞主线程，只有一种可能导致死锁，就是串行队列里，嵌套开启任务，有可能会导致死锁。 主线程队列中不能开启同步，会阻塞主线程。只能开启异步任务，开启异步任务也不会开启新的线程，只是降低异步任务的优先级，让cpu空闲的时候才去调用。而同步任务，会抢占主线程的资源，会造成死锁。 线程：里面有非常多的任务（同步，异步） 同步与异步的区别： 同步任务优先级高，在线程中有执行顺序，不会开启新的线程。异步任务优先级低，在线程中执行没有顺序，看cpu闲不闲。在主队列中不会开启新的线程，其他队列会开启新的线程。 主线程队列注意： 在主队列开启异步任务，不会开启新的线程而是依然在主线程中执行代码块中的代码。为什么不会阻塞线程？ 主队列开启异步任务，虽然不会开启新的线程，但是他会把异步任务降低优先级，等闲着的时候，就会在主线程上执行异步任务。 在主队列开启同步任务，为什么会阻塞线程？ 在主队列开启同步任务，因为主队列是串行队列，里面的线程是有顺序的，先执行完一个线程才执行下一个线程，而主队列始终就只有一个主线程，主线程是不会执行完毕的，因为他是无限循环的，除非关闭应用开发程序。因此在主线程开启一个同步任务，同步任务会想抢占执行的资源，而主线程任务一直在执行某些操作，不肯放手。两个的优先级都很高，最终导致死锁，阻塞线程了。 引用文章：08号风子]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 3D Touch使用]]></title>
    <url>%2F2017%2F12%2F13%2FiOS-3D-Touch%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[iOS9为我们提供了两种屏幕标签，分别是静态标签和动态标签。 1、静态标签 必填项（下面两个键值是必须设置的）： UIApplicationShortcutItemType 这个键值设置一个快捷通道类型的字符串 UIApplicationShortcutItemTitle 这个键值设置标签的标题 选填项（下面这些键值不是必须设置的）： UIApplicationShortcutItemSubtitle 设置标签的副标题 UIApplicationShortcutItemIconType 设置标签Icon类型 UIApplicationShortcutItemIconFile 设置标签的Icon文件 UIApplicationShortcutItemUserInfo 设置信息字典(用于传值) 2、动态标签 动态标签是我们在程序中，通过代码添加的，与之相关的类，主要有三个： UIApplicationShortcutItem 创建3DTouch标签的类 UIMutableApplicationShortcutItem 创建可变的3DTouch标签的类 UIApplicationShortcutIcon 创建标签中图片Icon的类 两种实现方式：一、 info.plist文件实现，需要做如下配置： 对于UIApplicationShortcutIconType苹果给了如下几种类型 typedef enum UIApplicationShortcutIconType : NSInteger { UIApplicationShortcutIconTypeCompose, UIApplicationShortcutIconTypePlay, UIApplicationShortcutIconTypePause, UIApplicationShortcutIconTypeAdd, UIApplicationShortcutIconTypeLocation, UIApplicationShortcutIconTypeSearch, UIApplicationShortcutIconTypeShare, UIApplicationShortcutIconTypeProhibit, UIApplicationShortcutIconTypeContact, UIApplicationShortcutIconTypeHome, UIApplicationShortcutIconTypeMarkLocation, UIApplicationShortcutIconTypeFavorite, UIApplicationShortcutIconTypeLove, UIApplicationShortcutIconTypeCloud, UIApplicationShortcutIconTypeInvitation, UIApplicationShortcutIconTypeConfirmation, UIApplicationShortcutIconTypeMail, UIApplicationShortcutIconTypeMessage, UIApplicationShortcutIconTypeDate, UIApplicationShortcutIconTypeTime, UIApplicationShortcutIconTypeCapturePhoto, UIApplicationShortcutIconTypeCaptureVideo, UIApplicationShortcutIconTypeTask, UIApplicationShortcutIconTypeTaskCompleted, UIApplicationShortcutIconTypeAlarm, UIApplicationShortcutIconTypeBookmark, UIApplicationShortcutIconTypeShuffle, UIApplicationShortcutIconTypeAudio, UIApplicationShortcutIconTypeUpdate } UIApplicationShortcutIconType; 二、代码动态实现：入口类AppDelegate 里方法定义对象@property (nonatomic, strong) UITraitCollection *traitCollection; - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions实现如下： if ([self respondsToSelector:@selector(traitCollection)]) { if ([self.traitCollection respondsToSelector:@selector(forceTouchCapability)]) { if (self.traitCollection.forceTouchCapability == UIForceTouchCapabilityAvailable) { // 支持3D Touch [self creatShortCutItem]; } else { // 不支持3D Touch } } } 接着实现方法 - (void)creatShortCutItem{ UIApplicationShortcutIcon *searchIcon = [UIApplicationShortcutIcon iconWithType:UIApplicationShortcutIconTypeSearch]; UIApplicationShortcutItem *searchItem = [[UIApplicationShortcutItem alloc] initWithType:@"com.xubojoy.search" localizedTitle:@"搜索" localizedSubtitle:@"subtitle" icon:searchIcon userInfo:nil]; UIApplicationShortcutIcon *playIcon = [UIApplicationShortcutIcon iconWithType:UIApplicationShortcutIconTypePlay]; UIApplicationShortcutItem *playItem = [[UIApplicationShortcutItem alloc] initWithType:@"com.xubojoy.play" localizedTitle:@"播放" localizedSubtitle:@"subtitle" icon:playIcon userInfo:nil]; [UIApplication sharedApplication].shortcutItems = @[searchItem,playItem]; } 两种方式都要实现点击进入APP的处理代理方法：- (void)application:(UIApplication *)application performActionForShortcutItem:(nonnull UIApplicationShortcutItem *)shortcutItem completionHandler:(nonnull void (^)(BOOL))completionHandler代理方法中实现： - (void)application:(UIApplication *)application performActionForShortcutItem:(nonnull UIApplicationShortcutItem *)shortcutItem completionHandler:(nonnull void (^)(BOOL))completionHandler{ if (shortcutItem) { if ([shortcutItem.type isEqualToString:@"com.xubojoy.search"]) { NSLog(@"APP没被杀死-- 进入搜索"); }else if([shortcutItem.type isEqualToString:@"com.xubojoy.play"]){ NSLog(@"APP没被杀死-- 进入播放"); } } if (completionHandler) { completionHandler(YES); } }]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS Touch ID 使用]]></title>
    <url>%2F2017%2F12%2F13%2FiOS-Touch-ID-%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[使用iPhone 指纹识别需要引入一下库：#import &lt;LocalAuthenticationLocalAuthentication.h&gt; 以下使用直接上代码： - (void)authenticateUser { //初始化上下文对象 LAContext* context = [[LAContext alloc] init]; context.localizedFallbackTitle = @"输入登陆密码"; //错误对象 NSError* error = nil; NSString* result = @"需要验证指纹"; /** 注意两者的区别， 首先支持的版本不同、 //LAPolicyDeviceOwnerAuthentication iOS 9.0 以上 //kLAPolicyDeviceOwnerAuthenticationWithBiometrics iOS 8.0以上 其次输入 密码次数有关 用kLAPolicyDeviceOwnerAuthenticationWithBiometrics 就好拉 最主要的是，前者 使用“context.localizedFallbackTitle = @"输入登陆密码";” 上面这个属性的时候，不能按我们设定的要求走，它会直接弹出验证 所以还是用后者，kLAPolicyDeviceOwnerAuthenticationWithBiometrics */ //首先使用canEvaluatePolicy 判断设备支持状态 if ([context canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&error]) { //支持指纹验证 [context evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics localizedReason:result reply:^(BOOL success, NSError *error) { if (success) { //验证成功，主线程处理UI NSLog(@"验证成功"); } else { switch (error.code) { case LAErrorSystemCancel: { NSLog(@"Authentication was cancelled by the system"); //切换到其他APP，系统取消验证Touch ID break; } case LAErrorUserCancel: { NSLog(@"Authentication was cancelled by the user"); //用户取消验证Touch ID break; } case LAErrorUserFallback: { NSLog(@"User selected to enter custom password"); [[NSOperationQueue mainQueue] addOperationWithBlock:^{ //用户选择输入密码，切换主线程处理 }]; break; } default: { [[NSOperationQueue mainQueue] addOperationWithBlock:^{ //其他情况，切换主线程处理 }]; break; } } } }]; } else { //不支持指纹识别，LOG出错误详情 switch (error.code) { case LAErrorTouchIDNotEnrolled: { NSLog(@"TouchID is not enrolled"); break; } case LAErrorPasscodeNotSet: { NSLog(@"A passcode has not been set"); break; } default: { NSLog(@"TouchID not available"); break; } } NSLog(@"%@",error.localizedDescription); } }]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取手机唯一标识符（UUID＋KeyChain）]]></title>
    <url>%2F2017%2F12%2F12%2F%E8%8E%B7%E5%8F%96%E6%89%8B%E6%9C%BA%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86%E7%AC%A6%EF%BC%88UUID%EF%BC%8BKeyChain%EF%BC%89%2F</url>
    <content type="text"><![CDATA[UDID的唯一性使得许多开发者可以从多个应用收集用户的许多隐私数据。这是苹果不允许的，在iOS 5的时候，废除掉相关信息。现在应用试图获取UDID被禁止且不允许上架。 这时候就需要另一种标识来替代这种唯一性，这就是接下来要讲的UUID使用UUID来作为设备的唯一标识。获取到UUID后，如果用NSUserDefaults存储，当程序被卸载后重装时，再获得的UUID和之前就不同了。使用keychain存储可以保证程序卸载重装时，UUID不变。但当刷机或者升级系统后，UUID还是会改变的。但这也是目前为止最佳的替代方法。 新建 DeviceInfoObject类，实现如下方法： 宏定义 define KEY_UUID @”com.xxxxx” + (NSString*)getDeviceUuid { CFUUIDRef puuid = CFUUIDCreate( nil ); CFStringRef uuidString = CFUUIDCreateString( nil, puuid ); NSString * result = (NSString *)CFBridgingRelease(CFStringCreateCopy( NULL, uuidString)); CFRelease(puuid); CFRelease(uuidString); //将字符串中"-" 全部替换成 "" NSString *str = [result stringByReplacingOccurrencesOfString :@"-" withString:@""]; return str; } + (NSMutableDictionary *)getKeychainQuery:(NSString *)service { return [NSMutableDictionary dictionaryWithObjectsAndKeys: (__bridge id)kSecClassGenericPassword,(__bridge id)kSecClass, service, (__bridge id)kSecAttrService, service, (__bridge id)kSecAttrAccount, (__bridge id)kSecAttrAccessibleAfterFirstUnlock,(__bridge id)kSecAttrAccessible, nil]; } + (void)save:(NSString *)service data:(id)data { //Get search dictionary NSMutableDictionary *keychainQuery = [self getKeychainQuery:service]; //Delete old item before add new item SecItemDelete((__bridge CFDictionaryRef)keychainQuery); //Add new object to search dictionary(Attention:the data format) [keychainQuery setObject:[NSKeyedArchiver archivedDataWithRootObject:data] forKey:(__bridge id)kSecValueData]; //Add item to keychain with the search dictionary SecItemAdd((__bridge CFDictionaryRef)keychainQuery, NULL); } + (NSString *)load:(NSString *)service { NSString *ret = @""; NSMutableDictionary *keychainQuery = [self getKeychainQuery:service]; id retGetDevice=nil; //Configure the search setting //Since in our simple case we are expecting only a single attribute to be returned (the password) we can set the attribute kSecReturnData to kCFBooleanTrue [keychainQuery setObject:(id)kCFBooleanTrue forKey:(__bridge id)kSecReturnData]; [keychainQuery setObject:(__bridge id)kSecMatchLimitOne forKey:(__bridge id)kSecMatchLimit]; CFDataRef keyData = NULL; if (SecItemCopyMatching((__bridge CFDictionaryRef)keychainQuery, (CFTypeRef *)&keyData) == noErr) { @try { retGetDevice = [NSKeyedUnarchiver unarchiveObjectWithData:(__bridge NSData *)keyData]; } @catch (NSException *e) { NSLog(@"Unarchive of %@ failed: %@", service, e); } @finally { } } if (keyData){ CFRelease(keyData); } ret = [retGetDevice objectForKey:KEY_UUID]; if([ret length]>0) { return ret; }else { NSMutableDictionary *uuidKVPairs =[NSMutableDictionary dictionary]; ret=[DeviceInfoObject getDeviceUuid]; [uuidKVPairs setObject:ret] forKey: KEY_UUID]; [DeviceInfoObject save: KEY_UUID data: uuidKVPairs]; return ret; } return ret; }]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AFNetworking系列之--对比AFNetwork 3.x 与 AFNetwork 2.x]]></title>
    <url>%2F2017%2F12%2F12%2FAFNetworking%E7%B3%BB%E5%88%97%E4%B9%8B-%E5%AF%B9%E6%AF%94AFNetwork-3-x-%E4%B8%8E-AFNetwork-2-x%2F</url>
    <content type="text"><![CDATA[AFNetworking支持HTTP请求和基于REST的网络服务（包括GET、POST、 PUT以及DELETE等），支持ARC。AFNetworking项目中还包含一些列单元测试。 AFNetworking 2.0开始使用NSURLConnection的基础API ，以及较新基于NSURLSession的API的选项。AFNetworking 3.0现已完全基于NSURLSession的API，删除了对 NSURLConnection的封装内容,这是因为NSURLSession能够完全替代NSURLConnection，并且具有很多优点: 支持后台运行的网络任务 暂停、停止、重启网络任务，不需要自己封装NSOperation 支持断点续传，异步下载 支持上传，异步上传 获取下载、上传的进度 注意:3.0版本最低支持版本是从iOS7 1.废弃的类废弃对NSURLConnection的支持 被删除的类： AFURLConnectionOperation AFHTTPRequestOperation AFHTTPRequestOperationManager 用以替代的是下面的类: AFURLSessionManager AFHTTPSessionManager 进行修改的类： UIImageView+AFNetworking UIWebView+AFNetworking.h UIButton+AFNetworking.h 如果你之前的开发是基于AFHTTPRequestOperationManager的网络请求现在你应该转到AFHTTPSessionManager下去进行 UIKit的迁移图片下载已经被重构，以遵循AlamofireImage架构与新的AFImageDownloader类。这个类的图片下载职责的代理人是UIButton与UIImageView的类目，并且提供了一些方法，在必要时可以自定义。类别中，下载远程图片的实际方法没有改变。 UIWebView的类目被重构为使用AFHTTPSessionManager作为其网络请求。UIAlertView的类目被废弃从AFNetworking 3.0之后UIAlertView的类目因过时而被废弃。并没有提供UIAlertController类目的计划，因为这是应用程序应处理的逻辑，而不是这个库。 下面进行新旧对比：AFNetwork 2.x AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager]; //设置网络请求超时时间 [manager.requestSerializer willChangeValueForKey:@"timeoutInterval"]; manager.requestSerializer.timeoutInterval = 30.0f; [manager.requestSerializer didChangeValueForKey:@"timeoutInterval"]; [manager.requestSerializer setValue:@"application/x-www-form-urlencoded;" forHTTPHeaderField:@"Content-Type"]; [self addHeaderParams:manager]; manager.responseSerializer.acceptableContentTypes = [NSSet setWithObjects:@"application/json",@"text/html",nil]; [manager POST:self.requestURL parameters:self.requestParams success:^(AFHTTPRequestOperation *operation, id responseObject) { (@"success-POST:%@",responseObject); } failure:^(AFHTTPRequestOperation *operation, NSError *error) { DebugLog(@"failurePOST:%@",error.description) }]; AFNetworking 3.x AFHTTPSessionManager *manager = [AFHTTPSessionManager manager]; [manager.requestSerializer willChangeValueForKey:@"timeoutInterval"]; manager.requestSerializer.timeoutInterval = 30.0f;//30.0f [manager.requestSerializer didChangeValueForKey:@"timeoutInterval"]; [manager.requestSerializer setValue:@"application/x-www-form-urlencoded;" forHTTPHeaderField:@"Content-Type"]; [self addHeaderParams:manager]; manager.responseSerializer.acceptableContentTypes = [NSSet setWithObjects:@"application/json",@"text/html",nil]; [manager POST:self.requestURL parameters:self.requestParams progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) { NSLog(@"success-POST:%@",responseObject); } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) { }]; 即：每次开启一个网络请求时，首先新建一个AFHTTPSessionManager，然后将相关的requestSerializer和reponseSerializer赋值；最后发起相应的GET/POST等请求。 如果是直接采用NSURLSession来请求网络，写法如下： NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:nil delegateQueue:[NSOperationQueue mainQueue]]; NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request completionHandler:completionHandler]; [dataTask resume]; 即：新建一个Session（多个请求要用共享的SessionManager/Session），然后新建task，激活task，完成网络请求。 共享原因：共享的Session将会复用TCP的连接，而每次都新建Session的操作将导致每次的网络请求都开启一个TCP的三次握手,共享会提升网络速度。 AFNetworking 3.x 提供的post方法： [manager POST: parameters: constructingBodyWithBlock: progress: success: failure:] [manager POST: parameters: progress: success: failure:] 不建议使用的方法： [manager POST: parameters: success: failure:]; [manager POST: parameters: constructingBodyWithBlock: success: failure:] AFNetworking缓存AFNetworking实际上使用了两个独立的缓存机制：(1)AFImagecache：一个提供图片内存缓存的类，2.x时继承自NSCache，3.x不再使用NSCache。AFImagecache3.x之前存在于UIImageView+AFNetwork，之后存在于AFAutoPurgingImageCache中。 (2)NSURLCache：仍使用原生缓存机制：NSURLCache。NSURLConnection默认的URL缓存机制，用于存储NSURLResponse对象：一个默认缓存在内存，通过配置可以缓存到磁盘的类。NSURLCache对每个NSURLRequest对象都会遵守缓存策略（NSURLRequestCachePolicy）。 注意：NSCache与NSURLCache没有任何关系3.0之前的缓存方法：存在于AFURLConnectionOperation类文件中。 - (void)setCacheResponseBlock:(NSCachedURLResponse * (^)(NSURLConnection *connection, NSCachedURLResponse *cachedResponse))block; 3.0之后：在类AFURLSessionManager中 - (void)setDataTaskWillCacheResponseBlock:(nullable NSCachedURLResponse * (^)(NSURLSession *session,NSURLSessionDataTask *dataTask, NSCachedURLResponse *proposedResponse))block; 描述： Sets a block to be executed to determine the caching behavior of a data task, as handled by the NSURLSessionDataDelegate method URLSession:dataTask:willCacheResponse:completionHandler:. @param block A block object to be executed to determine the caching behavior of a data task. The block returns the response to cache, and takes three arguments: the session, the data task, and the proposed cached URL response. 苹果系统缓存存储策略： { NSURLCacheStorageAllowed, //默认，可以存在内存（重启设备清除），可以存储磁盘（代码清除） NSURLCacheStorageAllowedInMemoryOnly, NSURLCacheStorageNotAllowed, } NSURLCacheStoragePolicy; 请求缓存策略： { NSURLRequestUseProtocolCachePolicy = 0, //默认策略 NSURLRequestReloadIgnoringLocalCacheData = 1,//忽略本地缓存，从源加载 NSURLRequestReloadIgnoringLocalAndRemoteCacheData = 4, // 忽略本地&服务器缓存，从源加载 NSURLRequestReloadIgnoringCacheData = NSURLRequestReloadIgnoringLocalCacheData, NSURLRequestReturnCacheDataElseLoad = 2, //先从缓存加载，如果没有缓存，从源加载 NSURLRequestReturnCacheDataDontLoad = 3, //离线模式，加载缓存数据（无论是否过期），不从源加载 NSURLRequestReloadRevalidatingCacheData = 5 // 存在的缓存数据先确认有效性，无效的话从源加载 }; typedef NSUInteger NSURLRequestCachePolicy; 清除所有的URL缓存Response：[[NSURLCache sharedURLCache] removeAllCachedResponses];]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTPS如何保护数据传输安全]]></title>
    <url>%2F2017%2F12%2F11%2FHTTPS%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8A%A4%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[HTTPS随着互联网整体的发展， HTTPS 也被越来越多的应用。 甚至苹果去年还曾经放言要强制所有的 APP 都使用 HTTPS，可见在如今的互联网它的重要性。 那么问题来了，为什么这么多大公司都在积极推进 HTTPS 呢，它和我们平时更多使用的 HTTP 协议究竟有什么区别呢？ 我用最简单的话语跟大家聊一聊。 HTTP 明文传输先从 HTTP 说起，我们过去使用的 HTTP 协议，最大的问题就是，它是明文传输的。因为当时的互联网还只是简单的信息发布，所以明文传输在那个时代并没有太大问题。但随着网络应用越来越复杂，简单的明文传输所带来的问题就显现出来了。 其中一个最突出的问题就是信息劫持。什么叫做劫持呢？简单来说，以我们现在所使用的互联网架构，在发送和接受一条网络请求时，并不是直接发送到目标主机的，而是要经过中间很多个路由器，才能到达主机。 因为 HTTP 是明文传输的，那么所有中间经过的路由器都可以看到你的信息，还可以修改你的信息。假如你请求一个网站，网站的主机给你返回它的主页，一段 HTML 信息： &lt;html&gt; &lt;title&gt;Hello&lt;/title&gt; &lt;body&gt; Hello world. &lt;/body&gt; &lt;/html&gt; 网站服务器发回给用户的这个信息不是直接到达他机器的，在这中间要经过很多路由器，如果中途经过的某个路由器使坏，对这条信息做了修改， 然后把修改后的内容转发给下一个路由器： &lt;html&gt; &lt;title&gt;Hello&lt;/title&gt; &lt;body&gt; Hello world. &lt;ad&gt;这是一条广告&lt;/ad&gt; &lt;/body&gt; &lt;/html&gt; 比如像上面这样，最终传输到用户设备上的主页就被恶意加入了一条广告。 而这一切，对用户来说是毫无感知的，这就是信息劫持的一个例子。像这种注入广告还算比较轻微的。如果更严重的甚至会窃取你的个人信息。 HTTPS 如何解决既然说明了 HTTP 的这个问题，那么我们就再来看看 HTTPS 是如何解决这个问题的。由于篇幅原因，我们只用最简单的语言描述，背后的原理和机制如果都讲清楚就需要比较大的篇幅了。 如果让我们来想，保证信息传输不被恶意篡改的话，会用什么方法呢？ 最容易想到的应该就是对信息进行加密后再传输了。其实 HTTPS 也是基于这个原理的， 只是机制更加完善。 先来从加密说起，常用的加密算法有对称加密和非对称加密。对称加密就是用一个秘钥，进行加密和解密。 非对称加密就是加密的时候用一个秘钥，解密的时候用另一个秘钥。 从我这个描述上来看，是不是非对称加密会更安全一些呢？ 那为什么还会有对称加密的存在呢？ 因为性能。非对称加密要比对称加密更加消耗计算性能。 使用加密算法可以加强传输过程的安全性，但单纯的加密还是不够的。为什么这么说呢，如果你开发的是一个 APP 客户端，这样的设计勉强够用，在你的服务器和客户端上面用同样的秘钥对信息加密和解密就可以让传输安全得到很大的提升。但你要保护好你的秘钥，不被泄露。 但如果你开发的是一个 Web 程序，那这种机制几乎就没办法使用了。因为访问你服务的是浏览器，而不是受你控制的客户端。你没有办法让一个通用浏览器来适配你服务器的特殊加密规则。所以这时候就需要一个更加标准化的传输加密协议，也就是 HTTPS 了。 HTTPS 实现原理HTTPS 相比于普通的加密传输，最根本的区别就是用于加密传输内容的秘钥是随机的。但 HTTPS 是怎么做到的呢？ 总部能把秘钥直接发送给对方吧，因为只要发送，就可能被中间路由器截获。秘钥如果被截获，整个加密算法也就没有意义了。 HTTPS 使用了更聪明的做法，引入了一个叫做数字证书的机制。简单来说，每个支持 HTTPS 的服务端，都会申请一个 SSL 证书。这个证书一般是从专业的证书颁发机构申请。 我们平时访问 HTTPS 网站的时候，浏览器地址栏一般会出现一个小锁头，点击这个小锁头就可以查看证书信息， 我们来看 苹果开发者中心 的证书：它的证书颁发机构是 GeoTrust。 为什么一定要从这些颁发机构申请证书呢？ 原因是 HTTPS 的证书链校验机制。比如我们请求 苹果开发者中心 的网站，它会先把证书信息发给我们的客户端。 然后我们客户端会做一个叫做证书链校验的操作。 所谓证书链校验，其实就是这样，每个证书都包含一个数字签名，用这个数字签名经过一系列算法，就可以匹配到上一级证书的签名，按照这个算法一直往上延伸，就可以匹配到最顶层证书的签名。就像上面 苹果开发者中心 那个证书的截图一样，证书是一级一级的树形结构。 匹配到最顶层证书有什么用呢？ 答案是我们的客户端会预置这些顶层证书，比如打开你的 mac 电脑的钥匙串程序，你会看到这样的内容：我们平时使用的设备都会预置这些证书颁发机构的根证书。还回到前面讨论的证书校验的讨论，当逐级网上找到根证书后，就会和我们预置的这些证书进行匹配，如果能找到相同的，就代表网站发给我们的证书是可信的。否则这个网站就不可信。 这就解释了为什么我们需要从证书颁发机构申请证书了，因为只有证书颁发机构才可以生成它们根证书下面的子证书，生成子证书需要私钥，只有证书颁发机构才有自己的私钥。 说了这么多证书，到底数字证书有什么用呢？ 它的作用其中一个是标识网站的身份，这个我们稍后会再详细介绍。 交换秘钥如果证书验证通过了，就会开始一个交换秘钥的过程。 服务端发给客户端的证书，除了包含上述的验证信息，还包含了证书的公钥。 客户端验证证书有效后，就会发送给服务端一条消息，表明当前客户端可以接受的加密算法等信息，这条信息使用证书给我们的公钥加密传输。 服务端接收到这条消息后，因为它拥有证书的私钥，所以它可以用私钥将信息解密出来。因为私钥不会传输，所以只要不发生其他方式的泄露，理论上只有服务端才可能对这条消息解密。 保证了这条消息的安全性。 服务端知道客户端可以接受哪些加密算法后，就会生成一个针对这些算法的对称秘钥，是的，对称秘钥。然后再用自己的私钥把对称秘钥加密后返回给客户端。 同样，客户端得到这条消息，还会用之前收到的证书公钥再解密，得到这个对称秘钥。 到此为止 HTTPS 的握手过程就完成了。 接下来，客户端就可以用这个对称秘钥给服务端发送消息了。 流程梳理上面说了这么多，大家或许会有疑惑，再一起梳理一下。 HTTPS 在交换证书和秘钥信息的时候，使用的是非对称加密。 而在真正的信息传输时，使用的是对称加密。 为什么在传输信息时使用对称加密呢，主要还是性能考虑。对于客户端来说对请求信息进行加解密的开销还是有限的。但如果到了服务端，着他机器要对它处理的所有请求都进行加解密，就会造成很大的性能开销了。 这也是为什么都说 HTTPS 的性能要比 HTTP 消耗大的原因了。它额外处理大量的加密和解密的工作。 HTTPS 是如何防止中间路由器劫持的呢？ 首先就是证书，因为证书的私钥是不会传输的，所以理论上只有服务端自己才会知道私钥。只要这个私钥不被泄露，那么其他的中间人就不可能解密信息。 证书交换的过程无法被解密，那么对称秘钥在传输过程中就不会被破解。所以在传输信息的时候就可以保证信息的安全了。 当然， HTTPS 并不是绝对安全的。比如我们上面说的，如果服务端自己的证书私钥被泄露了，那么中间路由器就可以解密你们秘钥交换时的信息，就可以破解加密传输了。 更严重的是，根证书的秘钥被泄露。 根证书的秘钥都是保存在证书颁发机构手中。如果这些秘钥被泄露，就可以用它们随意签发合法的子证书，这样中间路由器就可以根本不用转发你的请求，直接返回给你任何恶意信息，而这时候你完全感知不到。 根证书秘钥泄露的事情在现实中确实发生过，所以大家选一个靠谱的证书签发机构，也是保护自己信息传输安全的必备行动。关于 HTTPS 就跟大家聊这么多，我这里说的肯定不是最详细的，但如果你从未了解过这些机制，应该会对你有些用处。 为什么使用了https还是可以被抓包？1.https的加密没有安全问题，但它只是用来防止通信过程中被第三方获取明文。如果黑客能直接控制通信的双方（你的电脑，或服务器)，那么黑客肯定能看到https明文的。 2.所以，你用charles之所以能看到https明文，是因为你允许了charles在你的电脑上做手脚，关键就是你同意charles在你电脑上安装证书。 3.具体一点，charles通过使用了https代理功能，来完成查看https明文的目的，也就是SSL中间人攻击。简单来说，你并不是直接与https的另一端通信，而是与charles通信，charles再与另一端通信，这种结构下，charles才能看到通信明文。这个问题的原理比较复杂，涉及到整套RSA系统，想了解原理的话，建议去看【信息安全】相关书籍，但这类书籍的门槛非常高。另外Fiddle也有这个功能，而且原理也一样。 文章出自：都在谈论的 HTTPS，究竟它是如何保护数据传输安全的呢？]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析DES与AES、RSA三种典型加密算法的比较]]></title>
    <url>%2F2017%2F12%2F11%2F%E6%B5%85%E6%9E%90DES%E4%B8%8EAES%E3%80%81RSA%E4%B8%89%E7%A7%8D%E5%85%B8%E5%9E%8B%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[DES与AES的比较自DES 算法公诸于世以来，学术界围绕它的安全性等方面进行了研究并展开了激烈的争论。在技术上，对DES的批评主要集中在以下几个方面： 1、作为分组密码，DES 的加密单位仅有64 位二进制，这对于数据传输来说太小，因为每个分组仅含8 个字符，而且其中某些位还要用于奇偶校验或其他通讯开销。 2、DES 的密钥的位数太短，只有56 比特，而且各次迭代中使用的密钥是递推产生的，这种相关必然降低密码体制的安全性，在现有技术下用穷举法寻找密钥已趋于可行。 3、DES 不能对抗差分和线性密码分析。 4、DES 用户实际使用的密钥长度为56bit，理论上最大加密强度为256。DES 算法要提高加密强度（例如增加密钥长度），则系统开销呈指数增长。除采用提高硬件功能和增加并行处理功能外，从算法本身和软件技术方面都无法提高DES 算法的加密强度。 相对DES算法来说，AES算法无疑解决了上述问题，主要表现在以下几个方面： 1、运算速度快，在有反馈模式、无反馈模式的软硬件中，Rijndael都表现出非常好的性能。 2、对内存的需求非常低,适合于受限环境。 3、Rijndael 是一个分组迭代密码， 分组长度和密钥长度设计灵活。 4、AES标准支持可变分组长度，分组长度可设定为32 比特的任意倍数，最小值为128 比特，最大值为256 比特。 5、AES的密钥长度比DES大， 它也可设定为32 比特的任意倍数，最小值为12 比特，最大值为256 比特，所以用穷举法是不可能破解的。 6、AES算法的设计策略是WTS。WTS 是针对差分分析和线性分析提出的，可对抗差分密码分析和线性密码分析。 DES与RSA的比较RSA算法的密钥很长，具有较好的安全性，但加密的计算量很大，加密速度较慢限制了其应用范围。为减少计算量，在传送信息时，常采用传统加密方法与公开密钥加密方法相结合的方式，即信息采用改进的DES对话密钥加密，然后使用RSA密钥加密对话密钥和信息摘要。对方收到信息后，用不同的密钥解密并可核对信息摘要。 采用DES与RSA相结合的应用，使它们的优缺点正好互补，即DES加密速度快，适合加密较长的报文，可用其加密明文；RSA加密速度慢，安全性好，应用于DES 密钥的加密，可解决DES 密钥分配的问题。 目前这种RSA和DES结合的方法已成为EMAIL保密通信标准。 转载： 浅析DES与AES、RSA三种典型加密算法的比较]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS判断手机是否越狱]]></title>
    <url>%2F2017%2F11%2F30%2FiOS%E5%88%A4%E6%96%AD%E6%89%8B%E6%9C%BA%E6%98%AF%E5%90%A6%E8%B6%8A%E7%8B%B1%2F</url>
    <content type="text"><![CDATA[直接上正题！！！判断手机越狱的几种方式： 1.通过手机越狱后增加的越狱文件判断 static const char* jailbreak_apps[] = { "/Applications/Cydia.app", "/Applications/limera1n.app", "/Applications/greenpois0n.app", "/Applications/blackra1n.app", "/Applications/blacksn0w.app", "/Applications/redsn0w.app", "/Applications/Absinthe.app", "/Library/MobileSubstrate/MobileSubstrate.dylib", "/bin/bash", "/usr/sbin/sshd", "/etc/apt", "/private/var/lib/apt/", NULL, }; - (BOOL)isJailBreak { for (int i = 0; i < jailbreak_tool_paths.count; i++) { if ([[NSFileManager defaultManager] fileExistsAtPath:[NSString stringWithUTF8String:jailbreak_apps[i]]]) { NSLog(@"The device is jail broken!"); return YES; } } NSLog(@"The device is NOT jail broken!"); return NO; } 2.根据是否能打开cydia判断 - (BOOL)isJailBreak { if ([[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@"cydia://"]]) { NSLog(@"The device is jail broken!"); return YES; } NSLog(@"The device is NOT jail broken!"); return NO; } 3.根据是否能获取所有应用的名称判断,没有越狱的设备是没有读取所有应用名称的权限的。 - (BOOL)isJailBreak { if ([[NSFileManager defaultManager] fileExistsAtPath:@"User/Applications/"]) { NSLog(@"The device is jail broken!"); NSArray *appList = [[NSFileManager defaultManager] contentsOfDirectoryAtPath:@"User/Applications/" error:nil]; NSLog(@"appList = %@", appList); return YES; } NSLog(@"The device is NOT jail broken!"); return NO; } 4.根据使用stat方法来判断cydia是否存在来判断这个方法的思路还是通过判定cydia应用，但方法是使用stat函数，同时会判断是否有注入动态库。 int checkInject() { int ret; Dl_info dylib_info; int (*func_stat)(const char*, struct stat*) = stat; char *dylib_name = "/usr/lib/system/libsystem_kernel.dylib"; if ((ret = dladdr(func_stat, &dylib_info)) && strncmp(dylib_info.dli_fname, dylib_name, strlen(dylib_name))) { return 0; } return 1; } int checkCydia() { struct stat stat_info; if (!checkInject()) { if (0 == stat("/Applications/Cydia.app", &stat_info)) { return 1; } } else { return 1; } return 0; } 5.根据读取的环境变量是否有值判断DYLD_INSERT_LIBRARIES环境变量在非越狱的设备上应该是空的，而越狱的设备基本上都会有Library/MobileSubstrate/MobileSubstrate.dylib char* printEnv(void) { charchar *env = getenv("DYLD_INSERT_LIBRARIES"); NSLog(@"%s", env); return env; } - (BOOL)isJailBreak { if (printEnv()) { NSLog(@"The device is jail broken!"); return YES; } NSLog(@"The device is NOT jail broken!"); return NO; } 以上就是判断手机越狱的方法，但是为了保证判断的准确性，通常会多种方法联合使用。 越狱有风险，越狱需谨慎！！！参考文章 iOS 判断手机是否越狱]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Runtime妙用之-归档]]></title>
    <url>%2F2017%2F11%2F29%2FRuntime%E5%A6%99%E7%94%A8%E4%B9%8B-%E5%BD%92%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[对于数据存储的归档方式，实现NSCoding协议 - (void)encodeWithCoder:(NSCoder *)aCoder - (id)initWithCoder:(NSCoder *)aDecoder 直接上代码以UserModel说明，该类有定义两个属性name，gender。 @interface UserModel : NSObject\ @property (nonatomic, strong) NSString *name; @property (nonatomic, strong) NSString *gender; @end .m文件中文件中用常见方法实现NSCoding协议 - (void)encodeWithCoder:(NSCoder *)aCoder{ [aCoder encodeObject:self.name forKey:@"name"]; [aCoder encodeObject:self.gender forKey:@"gender"]; } - (instancetype)initWithCoder:(NSCoder *)aDecoder{ self = [super init]; if (self) { self.name = [aDecoder decodeObjectForKey:@"name"]; self.gender = [aDecoder decodeObjectForKey:@"gender"]; } return self; } 对于有少量属性的这样写还凑合，但是对于拥有大量属性的类来说，这样就要做很多体力活了，费时费力！！！然鹅—-苹果daddy还是给了更方便的实现方法，那就是Runtime登场了！见证奇迹的时刻到了！——————-对于归档咱可以这样来写： /** * 归档 */ - (void)encodeWithCoder:(NSCoder *)aCoder { unsigned int count; // 获得指向当前类的所有属性的指针 objc_property_t *properties = class_copyPropertyList([self class], &count); for (int i = 0; i < count; i++) { // 获取指向当前类的一个属性的指针 objc_property_t property = properties[i]; // 获取C字符串属性名 const char *name = property_getName(property); // C字符串转OC字符串 NSString *propertyName = [NSString stringWithUTF8String:name]; // 通过关键词取值 NSString *propertyValue = [self valueForKeyPath:propertyName]; // 编码属性 [aCoder encodeObject:propertyValue forKey:propertyName]; } free(properties); } 对于解档咱可以这样来写： /** 解档 */ - (id)initWithCoder:(NSCoder *)aDecoder { if(self = [super init]) { unsigned int count; // 获得指向当前类的所有属性的指针 objc_property_t *properties = class_copyPropertyList([self class], &count); for (int i = 0; i < count; i++) { // 获取指向当前类的一个属性的指针 objc_property_t property = properties[i]; // 获取C字符串的属性名 const char *name = property_getName(property); // C字符串转OC字符串 NSString *propertyName = [NSString stringWithUTF8String:name]; // 解码属性值 NSString *propertyValue = [aDecoder decodeObjectForKey:propertyName]; [self setValue:propertyValue forKey:propertyName]; } // 记得释放 free(properties); } return self; } 对于相同的部分也可以再提取，这里就不整了--🙃🙃🙃🙃🙃🙃 #### 接下来就是测试了： UserModel *model = [[UserModel alloc] init]; model.name = @"haha"; model.gender = @"未知"; //获取文件目录 NSArray *documentDirectories = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES); NSString *documentDirectory = [documentDirectories objectAtIndex:0]; NSLog(@"documentDirectory = %@",documentDirectory); documentDirectory = [documentDirectory stringByAppendingPathComponent:@"userModel.archive"]; //自定义对象归档存到文件中 [NSKeyedArchiver archiveRootObject:model toFile:documentDirectory]; //解档： UserModel* p = [NSKeyedUnarchiver unarchiveObjectWithFile:documentDirectory]; NSLog(@"name = %@,gender = %@",p.name,p.gender); 完毕！😑😑😑😑😑😑😑😑]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多设备更新博客]]></title>
    <url>%2F2017%2F08%2F17%2F%E5%A4%9A%E8%AE%BE%E5%A4%87%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[……..未完待续………..]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac本地搭建IPv6环境]]></title>
    <url>%2F2017%2F05%2F01%2FMac%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAIPv6%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[最近提交APP连着被拒三次，按照苹果的反馈，貌似是跟ipv6有关，无奈只能本地搭建ipv6环境做一次测试，虽然测试结果表明并非ipv6的原因，但还是要记录一下如何在mac电脑本地搭建ipv6环境： 一、在 “系统偏好设置（System Preferences）” 界面选中按住 “Option” 键，同时点击“共享（Sharing）”： 二、之后在 “共享” 界面中，会看到“创建 NAT64 网络 ” 的选框，选中它。期他按图示选中： 三、Wi-Fi选项可以自定义个性化热点 四、之后选中‘互联网共享’，点击‘启动’ 五、看到互联网共享打开，即ipv6hunjing创建完成 六、接下来手机连接mac创建的热点网络，这里手机最好是设置成飞行模式，以免蜂窝移动网络（即2G、3G、4G流量）对测试有干扰； 七、看到如下手机DNS连接，表示ipv6环境连接成功： 至此，本地搭建ipv6环境就大功告成，只需要打开要测试的APP测试即可！]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python猜数小游戏]]></title>
    <url>%2F2017%2F04%2F23%2FPython%E7%8C%9C%E6%95%B0%E5%B0%8F%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[设定目标值为20，允许最多猜三次，对与否都会退出程序 num = 20 count = 0 while count < 3: guess_num = int(input('age:')) if guess_num == num: print('you got it !') break elif guess_num > num: print('猜大了！') else: print('猜小了！') count = count + 1 #若要三次之后仍能继续，加入如下代码： #if count == 3: # countine_confirm = input('do you want to keep guessing...?') # if countine_confirm != 'n': # count = 0 else: print('再接再厉！')]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python几种格式化输出]]></title>
    <url>%2F2017%2F04%2F21%2FPython%E5%87%A0%E7%A7%8D%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[Python格式化输出name = input('name:') age = input('age:') userInfo = ''' ---------------- welcome ''' + name + '''----------- name:'''+name+''' age:''' + age userInfo1 = ''' ---------------- welcome %s ----------- name:%s age:%s ''' % (name,name,age) userInfo2 = ''' ---------------- welcome {_userName} ----------- name:{_userName} age:{_userAge} '''.format(_userName = name, _userAge = age) userInfo3 = ''' ---------------- welcome {0} ----------- name:{0} age:{1} '''.format(name, age) print(userInfo)print(userInfo1)print(userInfo2)print(userInfo3) 打印如下：四种方式效果一样---------------- welcome xubojoy ----------- name:xubojoy age:20]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清明桂林之旅]]></title>
    <url>%2F2017%2F04%2F19%2F%E6%B8%85%E6%98%8E%E6%A1%82%E6%9E%97%E4%B9%8B%E6%97%85%2F</url>
    <content type="text"><![CDATA[要么读书，要么旅行，身体和灵魂总有一个在路上! 在一个地方待太久了，有时候会觉得太累，有时候是因为工作，有时候是因为身边的人，因此总想出去走走，几经犹豫之后，还是决定了这次旅行。 决定出去走走了就什么都不想了，因为特别想体验一次一个人住青旅，自己就提前定了青旅的房间，坐上南下的高铁，比朋友早一天到达了目的地，一路上听着音乐，看着窗外的景色，看着由平原进入山区，内心还算平静，一个人一座陌生的城市，遇见陌生的面孔，同住一个房间的另外三个陌生人，聊了聊之后发现也都是一个人出来旅游，每个人都有自己的故事，每个人也都是带着不同的心情旅游的吧。 第二天朋友到了之后，就开始了为期两天半的旅途，由于没有完全按计划的行程，导致时间上还是显得有些匆忙了，但总的来说还是没有影响此次旅行的目的。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ios数据存储]]></title>
    <url>%2F2017%2F04%2F12%2Fios%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[常用方式:1、plist 2、NSUserDefault 3、NSKeyedArchiver归档 4、FMDB 一、plist plist文件的读与写 特点：只能存储OC常用数据类型(NSString、NSDictionary、NSArray、NSData、NSNumber等类型)而不能直接存储自定义模型对象如果想存储自定义模型对象 -&gt; 只能将自定义模型对象转换为字典存储； NSString *name = @"测试数据"; NSString *documentPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject]; NSString *strPath = [documentPath stringByAppendingPathComponent:@"str.plist"]; [name writeToFile:strPath atomically:YES encoding:NSUTF8StringEncoding error:nil]; NSLog(@">>>>>>>>>>>%@",strPath); NSString *tmpStr = [NSString stringWithContentsOfFile:strPath encoding:NSUTF8StringEncoding error:nil]; NSLog(@">>>>>tmpStr>>>>>>%@",tmpStr); 二、NSUserDefaultUserDefaults设置数据时，不是立即写入，而是根据时间戳定时地把缓存中的数据写入本地磁盘。所以调用了set方法之后数据有可能还没有写入磁盘应用程序就终止了。出现以上问题，可以通过调用synchornize方法强制写入 NSUserDefaults *userdefault = [NSUserDefaults standardUserDefaults]; //写入 [userdefault setBool:YES forKey:@"isLogined"]; [userdefault synchronize]; //读取 BOOL loginStatus = [userdefault boolForKey:@"isLogined"]; NSLog(@">>>>>loginStatus>>>>>>%@",(loginStatus==1)?@"YES":@"NO")]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[@yyyy和@YYYY之间有什么区别]]></title>
    <url>%2F2017%2F02%2F19%2Fyyyy%E5%92%8C-YYYY%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[NSDateFormatter中设置@”yyyy”和设置@”YYYY”之间有什么区别？ NSDate selDate = ((UIDatePicker)myDataPicker).date;NSDateFormatter date_formater=[[NSDateFormatter alloc]init];[date_formater setDateFormat:@”yyyy”/@”YYYY”*/];self.myStrFirst = [date_formater stringFromDate:selDate]; 两种方式选择日期时候，选择2010年12月27日时候返回数值不一样，@“yyyy”返回2010；@“YYYY”返回2011 只是有一点要特别注意：以后转换日期格式的时候记得还是用@“yyyy-MM-dd”这种格式吧，避免出现这种情况衍生的bug。 如果一月1日是星期一，星期二，星期三或星期四，它是在01周。如果一月1日是星期五，星期六或星期日，它在前一年的52周或53周]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub 上排名前 100 的 Objective-C 项目简介]]></title>
    <url>%2F2017%2F02%2F19%2FGitHub-%E4%B8%8A%E6%8E%92%E5%90%8D%E5%89%8D-100-%E7%9A%84-Objective-C-%E9%A1%B9%E7%9B%AE%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[项目名称 项目信息 AFNetworking 作者是 NSHipster 的博主, iOS 开发界的大神级人物, 毕业于卡内基·梅隆大学, 开源了许多牛逼的项目, 这个便是其中之一, AFNetworking 采用 NSURLConnection + NSOperation, 主要方便与服务端 API 进行数据交换, 操作简单, 功能强大, 现在许多人都用它取代 ASIHTTPRequest GPUImage 一款强大的图片滤镜工具, 支持自定义滤镜, 可用来实时处理图片和视频流, 作者是 SonoPlot 公司的 CTO, 在很小的时候便开始接触编程, 他在 SO 上面的回答也有很多值得阅读, GPUImage 这个项目从 2012 年开始, 使用 OpenGL 图形程序接口编写, 性能非常好, 现在很多 iOS 程序员都用它来实现 iOS 的模糊效果 SDWebImage 作者 Olivier Poitrey 是 Dailymotion 的 CTO, 拥有多个不错的开源项目, 此项目常用于对从 Web 端接受到的图片进行缓存, 是 UIImageView 的扩展, 应用起来比较简单 RestKit 主要用于 iOS 上网络通信, 允许与 RESTful Web 服务交互, 常用于处理 API, 解析 JSON, 映射响应对象等操作, 简单易用, 方便你把所有精力都放在对数据的操作上 ReactiveCocoa 由 GitHub 工程师们开发的一个应用于 iOS 和 OS X 开发的函数响应式编程新框架, Matt 称其为 “An open source project that exemplifies this brave new era for Objective-C”, 也有人说它是 Cocoa 的未来, 具体可看唐巧写的这篇文章 three20 由 Facebook iOS 客户端衍生出的一款 iPhone 框架, 内置许多丰富的功能, 有丰富的界面, 对底层的操作便捷, 为开发者省下了很多时间, 但现在已经停止了更新, 一个 PR 把代码删得干干净净, 不要好奇去点开 Files changed, 我点开后该页面直接卡死, three20 当中的一位作者创建了 Nimbus, 算是 three20 的一个替代品 MBProgressHUD 作者 Matej Bukovinski 是一位全栈工程师, UI/UX 设计师, 此项目是一款提示框第三方库, 帮助开发者快速应用到项目中) MagicalRecord 作者是 Coursera 的 iOS 工程师, 该项目创作灵感来自于 Ruby on Rails 的 Active Record, 主要为方便操作 CoreData 而生, 帮助清除 CoreData 引用的代码, 协助方便 CoreData 的工作 FMDB 一个对 SQLite 进行封装的库, 使用起来方便, 简单 Mantle 作者是 GitHub 的员工, 文档写的很清楚: Mantle makes it easy to write a simple model layer for your Cocoa or Cocoa Touch application, 主要用来将 JSON 数据模型化为 Model 对象, 唱吧在前段时间也改用 Mantle 了. FlatUIKit 收集了很多扁平化 UI 的 iOS 组件, 方便使用 ASIHTTPRequest 一个轻量级的 iOS 网络通信类库, 基于 CFNetwork 框架开发, 但现在已经停止更新, 多数开发者改用 AFNetworking 替代) FastImageCache Path 公司出品的 iOS 库, 作者 Mallory Paine 是苹果前员工, 此类库适用于在滚动时快速显示图像, 高速持久是其最大的特点 Masonry 一个轻量级的布局框架, 同时支持 iOS 和 Mac OS X, 语法优雅, 帮助开发者快速适配不同分辨率的 iOS 设备 Shimmer Facebook 推出的一款具有闪烁效果的第三方控件, 供它旗下一款名为 Paper 的应用使用, 安装使用整个过程都十分简单 SVProgressHUD 又一款轻量级的 iOS 第三方控件, 用于显示任务加载时的动画, 非常轻便, 容易使用 Slate 一款窗口管理应用程序, 但在两年前就已经停止更新了 JSONKit 主要用于解析 JSON, 适用于 iOS6 以下环境, 自从 iOS5 开始 Apple 官方给出了 NSJSONSerialization API, 自此大家都用官方的了 Nimbus 作者 Jeff 曾为 Facebook, Google 做过不少好东西, 也是 three20 的成员之一, three20 停更后, 他创造出这个框架来代替 three20, 文档齐全 CocoaLumberjack 这是 Mac 和 iOS 的一款强大的日志框架, 配置简单, 多线程, 提供更高级的 log 功能, 可用于代替默认的 NSLog 语句 Facebook SDK for iOS Facebook 官方的 iOS SDK, 方便开发者集成 Facebook 的一些功能到自己的 iOS APP 里面 AsyncDisplayKit Facebook 开源的一款 iOS UI 框架, Paper 用的就是该框架, 另外框架还用到了 Facebook 早期开源 Pop 动画引擎 Alcatraz Alcatraz 是一款管理 Xcode 插件、模版以及颜色配置的工具, 可以集成到 Xcode 的图形界面中, 安装删除都是几条命令的事, 很方便, 支持自己开发插件并上传 ViewDeck 一款开源的 iOS 活动面板组件, 还原 Path 2.0 的侧滑效果, 作者因为时间关系在两年前停止对其更新 JSQMessagesViewController 优雅的 iOS 消息类库, 常用于聊天应用中, 可定制性高 FLEX 这是 Flipboard 官方发布的一组专门用于 iOS 开发的应用内调试工具, 开发者无需将其连接到 LLDB/Xcode 或其他远程调试服务器,支持直接在 App 中运行 Xctool 是 Facebook 开源的一个命令行工具，用来替代苹果的 XcodeBuild 工具, 极大的方便了 iOS 的构建和测试, 输出错误信息也比较友好, 受到许多 iOS 开发者的称赞, 经常与其搭配使用的还有 OCUnit, Travis CI, OCLint 等测试工具 OpenEmu 超强的游戏模拟器, 做游戏开发必备, 官网做得也很不错 iCarousel 作者是英国 Charcoal Design 公司的创始人, 开源领域的贡献颇为卓著, 这个项目就是其中之一, 这是一款可以在 iOS 上实现旋转木马视图切换效果的第三方控件, 并提供多种切换效果 RESideMenu 作者 Roman Efimov 是雅虎的 iOS 工程师, 这个项目实现了 iOS 上的菜单侧滑效果, 创意来源于 Dribbble, 该项目支持 iOS8 PNChart 作者周楷雯是 90 后, 秒视的创始人, 该项目是一个带动画效果的图表控件, 简约易用, 受到不少开发者喜爱 PonyDebugger 由 Square 公司推出的一款优秀的 iOS 应用网络调试工具, 用户可以实时看到应用程序的网络请求, 也可以对 iOS 应用程序的核心数据栈进行远程调试 JVFloatLabeledTextField 作者是 Thumb Labs 的联合创始人, JVFloatLabeledTextField 是 UITextField 的子类, 主要实现输入框标签浮动效果, 创作灵感来自 Dribbble, 已出现多个移植版本 SWTableViewCell UITableViewCell 的子类, 实现了左右滑动显示信息视图并调出按钮 AwesomeMenu 作者是一位中国人, 该项目主要是使用 CoreAnimation 还原了 Path menu 的动画效果 Reachability Reachablity 是用于检测 iOS 设备网络环境的库 VVDocumenter-Xcode 作者是王巍国内著名的 iOS 开发者, 人称喵神, 目前在日本 LINE 公司工作, 该项目帮助开发者轻松的生成注释文档, 节省了不少工作量, 赞 The Physical Web 由 Chrome 团队主导的一个项目, 意在用 URL 连接世界, 方便用户接受数据, 目前尚处在实验阶段 NewsBlur 作者独自一个人 Samuel Clay 做出来的一款名为 NewsBlur 的新闻阅读器, 很多人都称其为 Google Reader 的替代品, 这是它的源码 Cocos2D-SpriteBuilder 一个可用于在 iOS, Mac 和 Android 上制作 2D 游戏或其它图形/交互应用的框架, 之前的项目名称为 Cocos Swift, 目前该项目在 GitHub 上更新较为频繁 TTTAttributedLabel UILabel 的替代品, 使 iOS 上的 Label 功能更加丰富, 可支持链接植入等功能 CocoaAsyncSocket 一个功能强大、简单易用的异步 socket 通讯类库, 支持 TCP 和 UDP 协议, 可用于 Mac 和 iOS 设备上, 作者 Robbie Hanson 是 Deusty 的首席软件工程师 TapkuLibrary 作者是 Devin Ross, 这是在 iOS 上一款功能强大的 UI 效果类库, 可以实现多种酷炫的效果, 目前仍在更新中 Canvas 无需编码实现牛逼的动画效果的库, 连设计师都可以快速上手 SocketRocket Square 公司开源的一个 WebSocket 客户端, 稳定并且易用, 做实时应用常会用到, 受广大开发者喜爱 ECSlidingViewController 一个视图控制器容器, 将子视图处理成两层, 通过滑动来处理层的切换, 创作灵感来自 Facebook 和 Path的 App, 作者是 Cleveland 的员工 Json Framework 用于解析 JSON 数据的一个框架, 但是在 iOS5 以上版本大多数人都选择使用 NSJSONSerialization 来解析 JSON, 该项目现在在 GitHub 上也几乎没怎么更新了 Tweaks Facebook 开源的一款工具, 旨在帮助 iOS 开发者更快的迭代应用, 方便用户动态的调整参数, 是的, Paper 这个项目也用到了 realm-cocoa Realm-Cocoa 是 Realm 公司推出一款移动端数据库, 可以运行在手机、平板和可穿戴设备之上, 其目标是取代 CoreData 和 SQLite 数据库 BlocksKit 一个开源的与 Cocoa 紧密集合的基础性框架 Appirater 一款用于提醒用户给你的 App 打分的工具 KIF Square 出品的一个开源的用户界面测试框架, 极大的简化了 iOS 开发者的 UI 测试流程 SlackTextViewController Slack 推出的一款具有文字输入框高度自适应, 自动输入, 复制单元格内容等功能的解决方案 JazzHands IFTTT 开源的一个简单易用的关键帧基础动画框架, 可通过手势、scroll views, KVO, ReactiveCocoa 等方式来控制动画 Bolts-iOS Bolts 是一个 Parse 和 Facebook 在内部使用的底层库, 方便移动开发 Spectacle 一款易用的 OS X 窗口分屏操作快捷键工具, 这是其源代码 nui 方便样式化 iOS 应用中的 UI 元素, 可在短时间内样式化整个应用, 类 CSS 原理 Induction Induction 是一款用于理解数据关系的管理工具, 这是其程序代码 JSONModel 一个能迅速解析服务器返回的 Json 数据的库, 方便数据的类型转换 DTCoreText 一个开源的 iOS 富文本组件, 它可以解析 HTML 与 CSS 并最终用 CoreText 绘制出来, 通常用于在一些需要显示富文本的场景下代替低性能的 UIWebView Popping 基于 Facebook Pop 引擎的 iOS 动画库, 集合了很多动画效果 TSMessages 一个用来弹出显示警告和通知的轻量级库, 样式丰富, 简单易用 KVOController 一个简单安全的 KVO(Key-value Observing, 键-值 观察)工具, 提供简单方便、线程安全的API, Facebook 的开源项目之一 MWPhotoBrowser 一款简单的 iOS 照片浏览控件 MMDrawerController 一个轻量级, 易于使用的侧边抽屉导航 iOS 控件 QuickDialog 用于快速创建复杂的 iOS 表单, 自定义了 UITableViewCell, TableView 的样式 SVPullToRefresh 一款只需一行代码便可集成上拉刷新和下拉加载的组件 cheddar-ios Cheddar 是一款简单易用的日程管理软件, 这是其早期版本的开源代码, 该项目已停止维护 XVim 一款在 Xcode 上实现了 Vim 功能的插件 EGOTableViewPullRefresh 一款提供下拉刷新的控件, 最后更新时间是一年前 iOS-boilerplate iOS 应用程序的基础模板, 使用该模板可以省掉许多项目初始编码的工作, 内置非常多丰富的功能, 现已经停止维护 JASidePanels 一个 UIViewController 容器, 灵感来自 Facebook 和 Path 2.0 应用的菜单, 实现了左右侧滑的操作 FormatterKit 收集了很多构思优秀的 NSFormatter 子类 MSDynamicsDrawerViewController 实现了具有动态弹性效果的抽屉式侧边导航栏, 效果丰富, 可定制性强 idev-recipes iDevRecipes 博客的代码, 演示如何实现一些有趣的控件, 该项目在两年前(2013)停止了更新 XMPPFramework 一个基于 RFC-3920 实现, 支持多线程和线程保护, 同时通用于所有的 iOS 和 Mac OS 开发设备的通信框架. MacGap1 一款可以将 HTML/CSS/JS 网络应用打包成原生 Mac App 的工具 FXBlurView iOS 模糊背景类库, 可以方便的根据底层显示的状态生成模糊效果 iOS7-Sampler 整合演示了多个具有 iOS7 新特性的的项目, 提供了非常多的例子参考 PromiseKit 提供强大的 iOS 开发异步功能, 是 Promises 的实现, 受到广大开发者的追捧 Origami 此为 Facebook 推出的 Quartz Composer 的一个开源插件, 由其设计团队花费了 9 个月打造而成, 目的是为方便设计师快速构建原型, 以零代码完成复杂动画的合成和测试, 堪称神器 NSLogger 一款强大的日志分析工具, 具有大窗口查看 Log, 自定义日志等级等功能 KSImageNamed-Xcode 一款对 UIImage 的 imageNamed 提供自动补全功能的插件, 非常方便 PureLayout 一个简单却强大的 AutoLayout API 库, 兼容了 Objective-C 和 Swift, 扩展了 UIView/NSView, NSArray, 和 NSLayoutConstraint AppleDoc 一款 Objective-C 文档生成工具, 生成的文档风格保持与 Apple 官方的一致, 极大的方便了 Xcode 识别自己写的 API 文档, 安装也是十分的简单 iTerm2 iTerm2 被不少程序员称赞为 Mac 下最好用的终端, 这是其源代码, 配合 oh-my-zsh 使用效果更佳 Kiwi 一个行为驱动开发测试框架, 适用于 iOS 平台, 旨在为开发者提供一个简单配置便可使用的 BDD 库 terminal-notifier 一款命令行工具, 用来给 Mac OS X 用户发送通知 MacDown Mac OS X 下的一款开源的 Markdown 编辑器, 创意来自与 Mou, 使用 brew cask 即可完成安装 TwUI Twitter 开源的一个支持硬件加速的 Mac 的 UI 框架, 最后一次的更新时间是在 3 年前(2012) PaperFold for iOS 实现了类似折纸效果的视图切换, 可从不同方向进行切换, 该项目已经许久未更新 Reader 一款开源的 iOS PDF 阅读器, 附带书签, 列纲要等功能 WebViewJavascriptBridge 一个方便使用 Objective-C 与 JavaScript 进行通信的第三方库, 支持消息发送, 接收, 消息处理器的注册与调用以及设置消息处理的回调 iOS8-Sampler iOSX-Sampler 系列之一, 整合演示了多个具有 iOS8 新特性的的项目, 提供了非常多的例子参考 CocoaHTTPServer 一个用于 Mac OS X 或 iOS 应用的轻量级、可嵌入的HTTP 服务器框架, 方便开发者在应用中嵌入一个 HTTP 服务器 Kod Mac OS X 上一款专为程序员打造的编辑器, 这是其开源代码, 可惜的是作者在 2011 年停止了维护 TPKeyboardAvoiding 下拉键盘在 iOS 移动文本字段的通用解决方案, 能够自动处理键盘弹出后出现遮挡到文本输入框的问题 MKNetworkKit 一个轻量级网络请求框架, 完全基于 ARC, 仅有两个类, 具有自主操作多个网络请求, 更加准确的显示网络活动指标等优点，设置简单, 高度灵活 AQGridView 一个命令行工具, 通过项目里的 .xcdatamodel 文件, 可以为每个 entity 生成两个类, 方便 CoreData 的使用 出处：objective-c版 Android 版本]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[检测手机蓝牙是否开启]]></title>
    <url>%2F2016%2F07%2F28%2F%E6%A3%80%E6%B5%8B%E6%89%8B%E6%9C%BA%E8%93%9D%E7%89%99%E6%98%AF%E5%90%A6%E5%BC%80%E5%90%AF%2F</url>
    <content type="text"><![CDATA[添加类库CoreBluetooth.framework ##### 导入 #importCoreBluetooth/CoreBluetooth.h 设置代理：CBCentralManagerDelegate 添加属性@property (strong , nonatomic) CBCentralManager *manager;//中央设备 创建实例,设置代理self.manager = [[CBCentralManager alloc]initWithDelegate:self queue:dispatch_get_main_queue()]; self.manager.delegate = self; 接下来会检测蓝牙状态 - (void)centralManagerDidUpdateState:(CBCentralManager *)central { if (central.state != CBCentralManagerStatePoweredOn) { NSLog(@"fail, state is off."); switch (central.state) { case CBCentralManagerStatePoweredOff: NSLog(@"连接失败了\n请您再检查一下您的手机蓝牙是否开启，\n然后再试一次吧"); _bluetoothFailState = BluetoothFailStateByOff; break; case CBCentralManagerStateResetting: _bluetoothFailState=BluetoothFailStateByTimeout; break; case CBCentralManagerStateUnsupported: NSLog(@"检测到您的手机不支持蓝牙4.0\n所以建立不了连接.建议更换您\n的手机再试试。"); _bluetoothFailState = BluetoothFailStateByHW; break; case CBCentralManagerStateUnauthorized: NSLog(@"连接失败了\n请您再检查一下您的手机蓝牙是否开启，\n然后再试一次吧"); _bluetoothFailState = BluetoothFailStateUnauthorized; break; case CBCentralManagerStateUnknown: _bluetoothFailState = BluetoothFailStateUnKnow; break; default: break; } return; } _bluetoothFailState = BluetoothFailStateUnExit; // ... so start scanning }]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算两日期相差天数]]></title>
    <url>%2F2016%2F07%2F25%2F%E8%AE%A1%E7%AE%97%E4%B8%A4%E6%97%A5%E6%9C%9F%E7%9B%B8%E5%B7%AE%E5%A4%A9%E6%95%B0%2F</url>
    <content type="text"><![CDATA[计算两日期相差天数 - (NSInteger)numberOfDaysFromTodayByTime:(NSString *)time timeStringFormat:(NSString *)format { // format可以形如： @"yyyy-MM-dd" NSDate *today = [NSDate date]; NSTimeZone *localTimeZone = [NSTimeZone systemTimeZone]; NSDateFormatter *formatter = [[NSDateFormatter alloc] init]; [formatter setTimeZone:localTimeZone]; [formatter setDateFormat:NSLocalizedString(format,nil)]; // 时分秒转为00:00:00 NSDate *today2 = [formatter dateFromString:[formatter stringFromDate:today]]; NSDate *newDate = [formatter dateFromString:time]; // 时分秒转为00:00:00 NSDate *newDate2 = [formatter dateFromString:[formatter stringFromDate:newDate]]; double dToday = [self longlongintFromDate:today2]; double dNewDate = [self longlongintFromDate:newDate2]; NSInteger nSecs = (NSInteger)(dNewDate - dToday); NSInteger oneDaySecs = 24*3600; return nSecs / oneDaySecs; } - (long long int)longlongintFromDate:(NSDate *)date{ return [date timeIntervalSince1970] * 1000; } 计算几天前后的日期 - (NSString *)getADayYouWantFromDate:(NSDate *)aDate withNumber:(NSString *)number { int a = 0; if ([number hasPrefix:@"0"]) { [number substringFromIndex:1]; a = -number.intValue; } else { a = number.intValue; } NSCalendar *gregorian = [[NSCalendar alloc] initWithCalendarIdentifier:NSGregorianCalendar]; NSDateComponents *componets = [gregorian components:NSWeekCalendarUnit | NSYearCalendarUnit | NSMonthCalendarUnit | NSDayCalendarUnit fromDate:aDate]; NSDateFormatter *dateDay = [[NSDateFormatter alloc] init]; [dateDay setDateFormat:@"yyyy-MM-dd"]; [componets setDay:([componets day] + a)]; NSDate *mydate = [gregorian dateFromComponents:componets]; return [dateDay stringFromDate:mydate]; } self.showLabel.text = [self getADayYouWantFromDate:[NSDate date] withNumber:self.numberText.text];]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清理Xcode多余的证书]]></title>
    <url>%2F2016%2F07%2F18%2F%E6%B8%85%E7%90%86Xcode%E5%A4%9A%E4%BD%99%E7%9A%84%E8%AF%81%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[清理Xcodebuild setting多余的证书路径：~/Library/MobileDevice/Provisioning Profiles]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ios限制小数点后只能输入两位]]></title>
    <url>%2F2016%2F07%2F14%2Fios%E9%99%90%E5%88%B6%E5%B0%8F%E6%95%B0%E7%82%B9%E5%90%8E%E5%8F%AA%E8%83%BD%E8%BE%93%E5%85%A5%E4%B8%A4%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[纯粹的限制小数点后两位- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string{ if (textField == self.amountTextField) { //如果输入的是“.” 判断之前已经有"."或者字符串为空 if ([string isEqualToString:@"."] && ([textField.text rangeOfString:@"."].location != NSNotFound || [textField.text isEqualToString:@""])) { return NO; } //拼出输入完成的str,判断str的长度大于等于“.”的位置＋4,则返回false,此次插入string失败 （"379132.424",长度10,"."的位置6, 10>=6+4） NSMutableString *str = [[NSMutableString alloc] initWithString:textField.text]; [str insertString:string atIndex:range.location]; if (str.length >= [str rangeOfString:@"."].location+4){ return NO; } } return YES; } 限制小数点后两位并且数值要大于0 - (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string { if ([textField.text rangeOfString:@"."].location==NSNotFound) { isHaveDian=NO; } if ([string length]>0) { unichar single=[string characterAtIndex:0];//当前输入的字符 if ((single >='0' && single]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[摘录]]></title>
    <url>%2F2016%2F07%2F04%2F%E6%91%98%E5%BD%95%2F</url>
    <content type="text"><![CDATA[在这个时代的青年，能够把自己安排对了的很少。越聪明的人，越容易有欲望，越不知应在哪个 地方搁下那个心。心实在应该搁在当下的。可是聪明的人，老是搁不在当下，老往远处跑，烦躁 而不宁。所以没有志气的固不用说，就是自以为有志气的，往往不是志气而是欲望。——《朝话 ：人生的省悟》 【人生要五耐】1耐冷：指世态炎凉。要忍得耐得，随遇而安。2耐苦：苦有很多种。要有安贫乐道的修养，应付种种苦难。3耐噪：即浮躁。心静如水，保持一颗平常心，寻回心中净土。4耐烦：人生难免陷入困惑。对此既要化解又要自我调整适，远离烦恼。5耐忙：要有事可干。在人生中尽情的享受忙碌的乐趣。 岁月蹉跎，流年光阴无法让人淡忘一切，拿得起，却未曾有人能够真正放得下。天蒙蒙，一副睡意朦胧的残月可否能安静的入睡，是否黎明的微光就能照耀你我心间？晨曦微凉的阳光可否让我忘却一个人，一段未开幕已然烟消云散的爱情故事？ 十多年来，你反复的推敲了这个演讲搞的每一个用词，现在可能已经完美了，你很想试着演讲一遍。但是没有一个听众。——《沉默的证人》 柏拉图说: 第一次哭是因为你不在，第一次笑是因为遇到你，第一次笑着流泪是因为不能拥有你 。。 The best friend is the silent company when you are sad and the reminder ofyour time together when you are apart.最好的朋友是那种在你难过时，默默地陪着你，什么也不用说的人，而当他离开时，你却会怀念和他一起的时光 有人说我，总是活在自己的世界中。后来我说，活在自己的世界中有什么不好，自给自足，偶尔庸人自扰，不是很好么？其实，我真的已经放下了。只是，我无比的怀念过去的那个自己，可以为了一切奋不顾身的自己。现在我只想没心没肺的笑着过每一天。 没有一成不变的绚烂，但不能停下追逐下一次绚烂的脚步，也许遇到的人会忘记，也许走过的路会荒芜，但旅行最大的好处，不是能见到多少人，见过多美的风景，而是走着走着，在一个际遇下，突然重新认识了自己 【非常道】弟子问老师：＂您能谈谈人类的奇怪之处吗？＂老师答道：“他们急于成长，然后又哀叹失去的童年；他们以健康换取金钱，不久后又想用金钱恢复健康。他们对未来焦虑不已，却又无视现在的幸福。因此，他们既不活在当下，也不活在未来。他们活着仿佛从来不会死亡；临死前，又仿佛他们从未活过。 一句再见，践行。一曲离歌，缘尽。彼此的以后，彼此的祝福，虽面带微笑，却已是别离笙箫恹恹，往事不堪回首。 谁都有脾气，但要学会收敛，在沉默中观察，在冷静中思考，别让冲动的魔鬼，酿成无可挽回的错；谁都有梦想，但要立足现实，在拼搏中靠近，在忍耐中坚持，别把它挂在嘴边，常立志者无志；谁都有底线，但要懂得把握，大事重原则，小事有分寸，不讲情面难得别人支持，过分虚伪亦让人避而远之。 每个人初恋，大都十分纯情。跨过了初恋，爱情就生出了很多姿态。有人变得风流，见一个爱一个；有人冷漠，再不会拿出真心爱第二个人；不是每个人，都适合与你白头到老。有的人，是拿来成长的；有的人，是拿来一起生活的；有的人，是拿来一辈子怀念的。。。 有些事注定成为故事，有些人注定成为故人，有些路注定要一个人走。一些人，一些事，闯进生活，得到了，失去的，昨天的悲伤，今天的快乐，喜怒哀乐都要记得。当一切都变成回忆，在我们记忆中又会留下什么？很多事，过去了，很多人，离开了，经历的多了，心就坚强了，路就踏实了。 【幸福的十七个秘决】1、忘记过去；2、对自己的生活负责；3、建立关系网络；4、寻找各种各样的激情；5、磨练自己的意志；6、成为你自己；7、为自己的人生目标生活；8、记得你获得的祝福；9、有积极的思想；10、有创意的工作。 永远不要后悔。 我们无法选择回去的路程，但是要清晰地面对已经造成的挑战。努力去调整，并相信自己会成功。无论你深处绝境，还是罹患疾病，你对过去无能为力，但在当下，你的未来并不那么渺茫，只要你努力，坚信自己，人生往往柳暗花明。 一些人一些事就这么明明灭灭地刻在沿途的风景中。我学会了安稳、学会了谎言、学会了冷静、学会了沉默、学会了坚忍。辗转中的快乐在百转千回中碎成一地琉璃，我站在风中把它们扫进心底最阴暗的角落，再也没有关系。那样明眸皓齿地对别人微笑，灵魂喷薄影子踯躅，只剩坚强无处不在。 有时候，我们活得很累，并非生活过于刻薄，而是我们太容易被外界的氛围所感染，被他人的情绪所左右。行走在人群中，我们总是感觉有无数穿心掠肺的目光，有很多飞短流长的冷言，最终乱了心神，渐渐被缚于自己编织的一团乱麻中。其实你是活给自己看的，没有多少人能够把你留在心上。 青春是打开了就合不上的书，人生是踏上了就回不了头的路 该放下时且放下，你宽容别人，其实是给自己留下来一片海阔天空。——于丹 Do not think about the past. Accept the Present. Think for the Future, and face tomorrow with a sweet and beautiful smile. 把人生当做饼干罐就可以了。饼干罐不是装了各种各样的饼干，喜欢的和不喜欢的都在里面吗？ 如果先一个劲儿的挑你喜欢吃的，那么剩下的就全是不大喜欢的。没次遇到麻烦我就这样想，先把这个应付过去，往下就好办了。人生就是饼干罐。 ——村上春树《挪威森林》 为了自己想过的生活，勇于放弃一些东西。这个世界没有公正之处，你也永远得不到两全之计。若要自由，就得牺牲安全。若要闲散，就不能获得别人评价中的成就。若要愉悦，就无需计较身边人给予的态度。若要前行，就得离开你现在停留的地方。——弗朗西丝?梅斯《托斯卡纳艳阳下》 在过了某个特定的年龄之后，我们生活中已不会再遇到任何新的人、新的梦境、新的面孔，新的事件：一切全都曾在过去发生过，它们全都曾经戴上不同的面具出现过；但它们其实是一样的，一切全都是过往的回音与循环往复；甚至所有的哀伤，也全都是许久以前一段伤痛过往的记忆重现。——莱辛《特别的猫》 有些时候如果情绪低落了，我就好想到动物园里去。 它们其实都很乖巧，不会多说话。我也不说话。于是经常，我们就像很熟悉的朋友一样，隔着不远的距离，各自想着自己的心事，却不尴尬。待四散而去时，就好像完成了一次轻描淡写的倾诉。——《陌生的城市》 我承认自己一直是不坚强的，光阴荏苒无数来回，声称自己改变了很多，宣布我已不是当年的我。但每每在深夜，却还是看到自己真实的心。我要的一直没变，只是许久不再提及以为所有的一切都淡去了。在他人面前日渐一日地成熟起来，表现出从容淡定，心以不可自知的速度，缓缓冷了下去。却以为 这就是成长。 【佛心佛语】天也空，地也空，人生渺茫在其中。 日也空，月也空，东升西沉为谁动。金也空，银也空，死后何曾握手中。 妻也空，子也空，黄泉路上不相逢。权也空，名也空，转眼荒郊土一封。 田也空，屋也空，换了多少主人翁。爱也空，恨也空，人生陌路不相逢。 喜也空，悲也空，无非都是在梦中。 我们怀念过去，并非放不下当初的人与事，而是怀想曾经的自己。人生是一次单边行程，很多东西都是唯一的，错过了就不可能再遇到。世界变化如此的快，我们一路行色匆匆，却怎么也跟不上它的脚步，丢失的东西越来越多，等到再回头看，已经找不回原来的自己。所以，保持一个本真的自我，是多么难的一件事。 有时候，就算你有钥匙，这些门还是打不开，就算门开了，你要找的人可能也不在了。——蓝莓之夜? 你要尽全力保护你的梦想。那些嘲笑你梦想的人，因为他们必定会失败，他们想把你变成和他们一样的人。我坚信，只要我心中有梦想，我就会与众不同，你也是。—-《当幸福来敲门》 张爱玲说。我以为爱情可以填满人生的遗憾。然而,制造更多遗憾的。却偏偏是爱情。 水说。 在我们每个人的内心深处，都藏着一个人，每次想起他的时候，会觉得…恩…有一点点心痛。 但我们依然愿意把他放在心底。就算今天，我不知道他在哪里，他在做些什么。 但至少知道，是他让我了解什么是—-&lt;&lt;初恋这件小事&gt;&gt;。 No matter how hard it is, just keep going because you only fail when you give up. 彼岸繁花，开一千年，落一千年，花叶不相见，情不为因果，缘注定生死，浮华苍桑，终究太多的伤。喧嚣、沉寂，终究躲不过悲凉。蝶恋天涯，迁移一季，守望一季，对影两相弃，爱不为情生，璨璨泪雨下，流年，残惜，终究太多的痛，繁花，没落，终究逃不过惆怅。 不要小看一分钱。不妨自己去挣挣看。做人有时要强悍一点，被欺负的时候，一定要讨回来！但是不要记恨。 任何时候，任何人问你，有过多少次恋爱，答案是两次。一次是他爱我，我不爱他。一次是我爱他，他不爱我。好的爱情永远在下一次。 如果彼此出现早一点，也许就不会和另一个人十指紧扣。又或者相遇的再晚一点，晚到两个人在各自的爱情经历中慢慢地学会了包容与体谅，善待和妥协，也许走到一起的时候，就不会那么轻易的放弃，任性地转身，放走了爱情。但时间不会回头，爱情岂能“如果”？ 有些风景，如果你不站在高处，你永远体会不到它的魅力；有些路，如果你不去启程，你永远不知道它是多么的美丽。 人都是逼出来的 每个人都是有潜能的。如果你简单，这个世界就对你简单 。怀才就象怀孕，时间久了会让人看出来。人生如果错了方向，停止就是进步。要成功，需要朋友，要取得巨大的成功，需要敌人。 生活里的累，一半源于生活本身，一半源于我们对待生活的态度。 生命都是太脆薄的一种东西，并不比一株花更经得住年月风雨，用对自然倾心的眼，反观人生，使我不能不觉得热情的可珍，而看重人与人凑巧的藤葛。在同一人事上，第二次的凑巧是不会有的。——《沈从文家书》 人生有三分之一在邂逅，三分之一在错过，三分之一在重逢。 Best way to not get your heart broken, is pretend you don’t have one. 春去秋来，一年的时间就弹指而过，很想找到回到过去的路，可怎么也找不到，就算是在梦里，也无法把它实现。我真的害怕唱着断点不再是让你流着泪，而是让我泪流成河。我害怕岁月见证了我老去的年轮。 错误的开始，注定了错误的结局。终于，你回归到了原点。我任性的来，固执的去。似水流年，散淡的时光里，留下了最初的时光。仿佛一切都不曾存在过。我安静的一个人生活。静静的，淡淡的，没有你的国度我的生活如此安然。 时间，也许我已经把他忘记，但时间转轴，转山转水转佛骨，将你转到我生命中来，不知道上天让我经历了多少个轮回，让我轮到你爱情中去。? 我想我们终于不再爱了，这样真好。我们给过彼此的那些眼泪和疼痛，如风飘远。——安妮宝贝《乔和我的情人节》 人生只有三天，活在昨天的人迷惑；活在明天的人等待；活在今天的人最踏实。你永远无法预测意外和明天哪个来得更早，所以，我们能做的，就是尽最大的努力过好今天。请记住：今天永远是昨天死去的人所期待的明天。。。 人生不售来回票，失去的便永远不再有。“我们都老得太快，却聪明得太迟。”? Let your past make you better, not bitter. 让你的过去推动你更多成长，而不是增添更多怨恨。 没有人陪你走一辈子，所以你要适应孤独，没有人会帮你一 辈子，所以你要奋斗一生。 总有一天，你的棱角会被世界磨平，你会拔掉身上的刺，你会学着对讨厌的人微笑，你会变成一个不动声色的人。总是觉得，还没有准备好就已经长大了。大人的世界蛮累的很难懂，有那么多字典里无法解释的字眼，还有那么多努力做好了也不会被所有人喜欢的事情，这些都要坦然面对。 远路从近处开始，大事从小处开始；很近的路，你不走也会感到很远，再远的路，昼夜兼程也会觉得很近！ 一个青年人一定要比同龄人see farther ，think deeper ，do more ！ 如果你想知道什么是希望，买一张彩票；如果你想知道什么是绝望，买一堆彩票。 Chase down your passion like it’s the last bus of the night. ——Terri Guillemets 追逐你的激情就像追逐末班车一样。 We make progress if, and only if, we are prepared to learn from our mistakes. 中国有一代人，读大学时，小学不要钱，读小学时，大学不要钱，没工作时，工作是分配的，可以工作时，被自谋职业，没挣钱时，房子是分配的，能挣钱时，发现根本买不起房子娶不到老婆，没有进股市时，傻子都挣钱，等进股市时自己成了傻子，抱怨后依然坚韧的活着，他们就是80后. Stand tall and none can look down to you. 人生如同坐火车，风景再美也会后退，流逝的时间和邂逅的人终会渐行渐远，前行的始终是自己。 不管全世界所有人怎么说，我都认为自己的感受才是正确的。无论别人怎么看，我绝不打乱自己的节奏。喜欢的事自然可以坚持，不喜欢的怎么也长久不了。——村上春树《当我谈跑步时，我在谈什么》 旅行是一种追求，一种期待，一种幸福。片刻的放空，是为了寻求心灵的休憩。穿行在茫茫尘世，洗净铅华，在路上，见识世界；在途中，认清自己。 【对自己的懒惰下手】人都只能靠自己。 1、没什么背景，没遇到什么贵人，也没读什么好学校，这些都不碍事。2、关键是，你决心要走哪条路，想成为什么样的人，准备怎样对自己的懒惰下黑手。3、 向前走，相信梦想并坚持。 你的容颜，终成我绘不出的青花图案，乱了我三世遗憾，我终是过不了你的劫，我埋了那往昔，却终究错过了你，你的流年，在似锦如花的最深处走过，不是为我，却乱了我的浮生！你一低头，写尽我一生的伤怀。 【稻盛和夫的人生修炼】1、工作时，付出不亚于任何人的努力。2、处事时，不忿怒，不嫉妒，不轻浮，不骄傲自恣。3、灾难时，不悲叹，不怨恨，不消沉，不灰心，不牢骚满腹。4、幸运时，不得意忘形，不失谦虚之心。5、萧条时，要有远见，要忍耐，不慌张。 三件让人幸福的事情：1、有人爱。2、有事做。3、有所期待。有人爱，不仅仅是被人爱，而且有主动爱别人爱世界的能力；有事做，让每一天充实，事情没有大小，只有你爱不爱做；有所期待，生活就有希望，人不怕卑微，就怕失去希望，期待明天，期待阳光，人就会从卑微中站起来拥抱蓝天。 乔布斯在17岁时读到一句话：“如果你把每一天都当做生命的最后一天去生活，那么有一天你会发现你是正确的。”从那时起的30多年里，他就是这样做的。 你说，一场樱花一场爱，于是人间情未央。我说，一场旧梦一场空，于是人间七月天。你说，一场烟火一场梦，于是人间夜未央。我说，一场繁华一场景，于是人间爱相随。 干不完的工作，停一停，放松心情；挣不够的钱财，看一看，身外之物；接不完的应酬，辞一辞，有利健康；尽不完的孝心，走一走，回家看看；还不完的人情，掂一掂，量力而行；走不 完的前程，缓一缓，漫步人生！ 这些日子，仰望天空，脑海中会浮现许多人的样子。一些人离开，没有归期；一些人离开，永不再会。好像只是我一个人留在原地。等待，或者怀念。怀念离开的人留在掌心的记忆，等待未来的人给我新奇。常常分不清楚，到底是物是人非了，还是人是物非了。 所谓长大，就是把原本看重的东西看轻一点，原本看轻的东西看重一点。很多人闯进你的生活， 只是为了给你上一课，然后转身离开。当一切都静下来的时候，突然发现习惯是一件可怕的事情，让人戒不掉，忘不了。——丁当《长大》 【职场谋略之养晦法则】1、语速放慢，但是做事要快 2、话不要说太多，也不要太少，避开锋芒，也不孤立自己 3、沉稳中学会躲避暗箭 4、不要与上司表现太过亲密 5、永远铭记：爬的越快，摔得越惨 6、永远不要以为表露自己是抓住机会，枪打出头鸟★ Sometimes we feel tired because we are lost in our life. Life consists not in holding good cards but in playing those you hold well。 生活总是美好的，生命在其间又是如此短促，既然活着，就应该好好的活。…………《平凡的世界》 总有一天，会有一个人，看你写过的所有状态，读完你写的所有日志，看你从小到大的所有照片，甚至去别的地方寻找关于你的信息，试着听你听的歌，走你走过的地方，看你喜欢看的书，品尝你总是大呼好吃的东西……只是想弥补上，你的青春里他/她迟到的时光 幸福的人都喜欢沉默。一直喋喋不休说自己如何幸福的人一定内心是虚弱的。当一个人内心足够强大时，说与不说，都已无用。最重要的是，选择最适合自己的方向，一意孤行走下去。找到生命中最确定的信息—那些相似的人或事物终会走到一起，那些不相似的人或事物，终会背道而驰。 When I can see you my body is with you, and when I can\’t see you my heart is with you.看得见你我的身体和你在一起，看不见你我的心和你在一起。 凉去的茶水，远去的年华，一度随思念淡去。这漫漫人生，我试着拾起曾经遗失的记忆，繁华落尽，那段美丽的日子，即使平凡，却是如此铭心，难以忘记 一片痴心，二地相望，下笔三四字，泪已五六行，但求七夕鹊桥会，八方神明负鸳鸯，九泉底下十徘徊，奈河桥上恨正长，肠百折，愁千缕万般无奈把心伤。 Failure does not imply you have wasted time and life. It shows you have reasons to start again.失败并不意味着你浪费了时间和生命，而是表明你有理由重新开始。 【建立人脉9大潜规则】①想钓到鱼，就要像鱼那样思考；②不要总显示比别人聪明；③让对方作主角，自己甘愿做配角；④目中无人，让你一败涂地；⑤常与人争辩，你永难赢；⑥锋芒太露，下场不好；⑦刺猬原则-保持适当距离；⑧树一个敌等于立一堵墙；⑨谦虚不虚伪不苛求完美。 感情不需要诺言、协议与条件。它只需要两个人：一个能够信任的人，与一个愿意理解的人。 If you don’t understand my silence, you will never understand my words.如果你不懂我的沉默，你也永远不会明白我说的话语。 有人说，如果你很想要一样东西，就放它走。如果它回来找你，那么它永远都是你的。要是它没有回来，那么不用再等了，因为它根本就不是你的！——《海滩》 有人说恋爱最美的时期，就是暧昧不清的阶段。—-《那些年，我们一起追过的女孩》 或许我曾经做过的最好的事，就是对你一如既往并且未曾动摇的坚持—- 源远《我就乐意这样寂寞了》 一个成熟的人往往发觉可以责怪的人越来越少，人人都有他的难处。——《我们不是天使》 两个人就算他们属相相克，八字不合，星座不配，恋爱指数为零。只要真心相爱，这些都不重要了。——《北京爱情故事》 生活不可能像你想象的那么好，但也不会像你想象的那么糟。我觉得人的脆弱 和坚强都超乎自己的想象。有时，我可能脆弱得一句话就泪流满面；有时，也发现自己咬着牙走了很长的路。——莫泊桑 情不知所起，一往而深。生者可以死，死可以生。生而不可与死，死而不可复生者，皆非情之至也。——《牡丹亭》 看别人的生活时，我们总喜欢放大他们的幸福，忽略他们生活中的不幸，所以别人的生活怎么看都觉得幸福。而在看待自己的生活时，人们总喜欢缩小自己的幸福，扩大自己的烦恼，所以我们对自己的生活总有太多的不满。 人生最奇怪的事情是，花十分之一的时间感叹童年过得太慢，花另外十分之九的时间感叹童年过得太快。 有时候我们有些近视，忽略了离我们最真的情感；有时候我们有些远视，模糊了离我们最近的幸福。一辈子真的很短，远没有我们想象的那么长，永远真的没有多远。所以，对爱你的人好一点，对自己好一点，今天是你的枕畔人，明天可能成了陌路人，如果这辈子来不及好好相爱，就更不要指望下一辈子还能遇见。 我们的一生都会遇到很多人，会告别很多人，会继续往前走。也许还会爱上那么几个人，弄丢那么几个人。关键在于，谁愿意为你停下脚步？对于生命中每一个这样的人，一千一万个感激。——卢思浩《你的青春弄丢了谁》 我们最大的悲哀，是迷茫地走在路上，看不到前面的希望；我们最坏的习惯，是苟安于当下生活，不知道明天的方向。 When someone says you have changed, but because you no longer accordingto their way of life habit stopped.当有人说你变了的时候，不过是因为你不再按他们习惯的方式生活罢了。 生命的天空里，有风和日丽，亦有云遮雾障。不是每轮艳阳都暖人，不是每片乌云都下雨。既然决定不了命运的走向，那就踏实走过每一天；既然左右不了天空的变幻，那就悉心装扮自己的心空。请相信：珍惜了，能拥有；付出了，有回报；走过了，不后悔。 如果把西游记倒过来看：如来派师徒四人与八部天龙小白龙去东土大唐去传教,在一路上遇到了各种妖怪,打来打去发现他们都是有后台的,无论怎么作恶都不受惩罚，八戒和沙僧觉得太黑暗了,无奈一个躲进了高老庄,一个钻进了流沙河,只有悟空坚持正义一路斩妖除魔护送师傅东去传教。结果天庭对悟空实在忍无可忍就和如来达成协议——我们可以保证唐三藏平安到长安,不过你得把孙悟空这个刺儿头给办了, 如来同意了，在一翻阴谋之下，白龙重伤坠入山涧，悟空败了，被压在了五指山下,而唐三藏却抛弃了孙悟空，孤身来到长安，在长安传完教，被封为御弟，享受完荣华富贵，寿终正寝。就这样过了五百年, 悟空终于从五指山下逃了出来, 一声不吭 ,把天庭搅了个天翻地覆, 天庭被逼无奈许诺让猪八戒化为人身，封为天蓬元帅，沙和尚封为卷帘大将，只要他们能够杀掉孙悟空。最后的最后，因为兄弟相残而心灰意冷的悟空去寻找菩提祖师解惑，然后他封印了修为，回到花果山，陪着猴子猴孙过完了平凡的一生，最终在花果山的山顶化作了一块石头… 多少人爱你青春欢畅的时辰，爱慕你的美丽，假意或者真心，只有一个人爱你那朝圣者的灵魂，爱你衰老了的脸上痛苦的皱纹.——叶芝《当你老了》 有时总想让自己活得潇洒快乐一些，对身边的人或事物表面上显的风平浪静，可心中却波涛汹涌，羡慕一些人的坦然，做自己的自己，可事实上又有谁能如此？ 生活有两大误区：一是生活给人看，二是看别人生活。只要自己觉得幸福就行，用不着向别人证明什么。不要光顾着看别人，走错了自己脚下的路。 这个世界上你认识那么多的人，那么多人和你有关，你再怎么改变也不能让每个人都喜欢你，所以还不如做一个自己想做的人。人生都太短暂，去疯去爱去浪费，去追去梦去后悔。——《青春里最后的任性》 今天是明天的记忆。我们说过的话，做过的事，走过的路，遇过的人，都是我们以后回忆的轨迹。我们无须缅怀昨天，不必奢望明天，只要认真地过好每一个今天，说能说的话，做可做的事，走该走的路，见想见的人。 The past is the past, looking back at it will only damage the present, leaving the future on hold.过去的就过去了，一直回头看只会毁掉现在，阻碍未来。 流年，总喜欢穿心而过，遇见，似一场花开。我站在岁月的转角，感叹生命中的倾心相遇与无常的别离。有的时候，刹那便是永恒。暮然回首，苍老的是岁月，永不老去的是初见的明媚与温暖。 东西，你遭受的每一次苦难，都会在你一生中的某个时候派上用场。——菲茨杰拉德《离岸》 Every storm brings with it hope that somehow by morning, everything will be made clean again. And even the most troubling stains will have disappeared.每随风暴而来的是希望——不论如何，到了早晨，一切都会变干净，即使最顽固的污点也会消失。《绝望的主妇》 生命中十个无能为力的事情，看了你会想开看开很多1、离你而去的人。2、流逝的时间。3、倒向你的墙。4、没有选择的出身。5、莫名其妙的孤独。6、无可救药的喜欢。7、无可奈何的遗忘。8、永远的过去。9、别人的嘲笑。10、不可避免的死亡。? 生活不可能像你想象得那么好，但也不会像你想象得那么糟。我觉得人的脆弱和坚强都超乎自己的想象。有时，我可能脆弱得一句话就泪流满面，有时，也发现自己咬着牙走了很长的路。 生活，是一种缓缓如夏日流水般地前进，我们不要焦急我们三十岁的时候，不应该去急五十岁的事情，我们生的时候，不必去期望死的来临，这一切，总会来的。——三毛 在这个光怪陆离的人间，没有谁可以将日子过得行云流水但我始终相信，走过平湖烟雨，岁月山河，那些历尽劫数、尝遍百味的人，会更加生动而干净。时间永远是旁观者，所有的过程和结果，都需要我们自己承担。 人生的路上，有一条路每一个人非走不可，那就是年轻时候的弯路。不摔跟头，不碰壁，不碰个头破血流，怎能炼出钢筋铁骨，怎能长大呢？ 岁月无声，它会让彼此陌生的人变得熟悉，也会因为岁月的无情，让两个熟悉的 人慢慢变得陌生。那些很尖锐的棱角，都会被岁月磨平，那些浮躁的人，也会变 得沉稳，岁月在融化，也在铸造，熔铸的我们都失了个性，徘徊在茫茫人海里， 谁都分布不清哪些才是真。——文摘之《岁月无声》 1、立志要如山，行道要如水。不如山，不能坚定；不如水，不能曲达。2、心境善，事事皆善；心境美，事事皆美。3、人的后半生是让前半生点亮的。4、痛苦是人生的拐杖，它使强者更强，弱者更弱。5、年轻时躺在玫瑰上，年老时就会躺在荆棘上。 我们的生命，就是以不断出发的姿势得到重生。为某些只有自己才能感知的来自内心的召唤，走在路上无法停息。—— 安妮宝贝《彼岸花》 In the arithmetic of love, one plus one equals everything, and two minus oneequals nothing.-Mignon McLaughlin 爱情的方程式：1+1=一切；2-1=0。-米扬?麦克劳克林 红尘陌上，独自行走，绿萝拂过衣襟，青云打湿诺言。山和水可以两两相忘，日与月可以毫无瓜葛。那时候，只一个人的浮世清欢，一个人的细水长流。– 林徽因 生活不可能像你想象得那么好，但也不会像你想象得那么糟。我觉得人的脆弱和坚强都超乎自己的想象。有时，我可能脆弱得一句话就泪流满面，有时，也发现自己咬着牙走了很长的路。 每个人的心里都潜藏着一条悲伤的河流。你有你的疼痛，我有我的艰辛，并非不懂，只是无暇顾及。如人饮水，冷暖自知。想要温存永生，只需嘴角上扬，那就是最美好的故事。 生活中很多时候很多事情，我们原本计划得很好，想像得很美，可往往走着走着，一切就慢慢变了，变得不那么美好，有时甚至变成了一个任务，一个包袱。如同旅行，本是一件轻松快乐的事，结果往往成了在路上奔波，只为了那一个个景点的到此一游，却错过了走走停停旅行的意义。 年轻时候最大的财富，不是你的青春，不是你的美貌，也不是你充沛的精力，而是你有犯错误的机会。如果你年轻时候都不能追随自己心里的那种强烈愿望，去为自己认为该干的事，冒一次风险，哪怕犯一次错误的话，那青春多么苍白啊！—— 杨澜 Some people succeed because they are destined to, but most people succeed because they are determined to! 有些人成功，是因为他们命中注定要成功；但绝大部分人成功，是因为他们下定决心要成功！ ——Graeme Clegg（格雷姆•克莱格） 【唯美诗词】1.用我三生烟火，换你一世迷离。2.听弦断，断那三千痴缠。坠花湮，湮没一朝风涟。花若怜，落在谁的指尖。3.山有木兮木有枝，心悦君兮君不知。4.待浮花浪蕊俱尽，伴君幽独。5.天不老，情难绝。心似双丝网，中有千千结。 生活中我们的烦恼常常如此：得不到的不甘心，得到了怕失去，总以为别人得到的比自己的好。生命在闪耀中峥嵘，在凡俗中真实，属于你的就是心仪的，拥有的就是最好的。所以，今天要倍加珍惜，错过了不会再来；昨天已随风吹散，无须暇想既往的情结；明天还很遥远，我们只能在当下的努力中嗅出它的味道 我多么希望，有一个门口。早晨，阳光照在草上。我们站着，扶着自己的门窗，门很低，但太阳是明亮的。草在结它的种子，风在摇它的叶子，我们站着，不说话，就十分美好。 —— 顾城《门前》。 出门向左，如果有一件事只有一个人做的到，那他一定是天才，但有一群人做的到，那就一定是能通过努力做到的! Once in a moment,we think oneself grow up, one day, we finally found the meaning of desire and grew up courage and strong except,as well as some must sacrifice.曾经在某一个瞬间，我们以为自己长大了，有一天，我们终于发现，长大的含义除了欲望还有勇气和坚强，以及某种必须的牺牲。 郑微一个人像白天的时候那样在校园里晃呀晃，她觉得她以前十八年来的心事都没有这一天那么多。她不明白，人世间的感情为什么不能像打地基一样，挖一个坑，就立一个桩，所有的坑都有它的那根桩，所有的桩也能找到它的那个坑，没有失望，没有失败，没有遗恨，永不落空。 他口气里对陈孝正的不以为然激怒了郑微，她可以讨厌陈孝正，但是她受不了别人对他的轻视，“没错，他没你家里有钱，长得也不见得比你好，他什么都没你好，但是你爱我，我却爱他，就凭这一点，你就永远输给了他！”这是多么伤人的一句话啊！也许只有年少时的无知无畏才能如此的肆无忌惮，郑微话说出了口就后悔了，然而她知道，那是她心里真正的想法，虽然后来她才明白过来，开阳不是输给了陈孝正，他是输给了她，正如她输给了陈孝正，谁先爱了，谁就输了。 走回宿舍的路上，她的烦乱渐渐一扫而空，眼前是一条路，她要去的地方已经毫无疑问，需要想一想的只是该怎么走，但不管怎么走，她相信，条条大路通罗马，总有一天，她郑微会走到陈孝正那家伙的心里，然后，郑重的在那里插上她的五星红旗。 时间会告诉你一切真相。有些事情，要等到你渐渐清醒了，才明白它是个错误；有些东西，要等到你真正放下了，才知道它的沉重。也许最沉重的负担同时也是一种生活最为充实的象征，负担越沉，我们的生活也就越贴近大地，越趋近真切和实在。 生命承载不了太多的沉重，如果不及时丢弃一些东西，我们将会不堪重负，脚步蹒跚。记忆就像一只钱夹，装得太多就会合不上，里面的东西还会全部掉出来。生命注定要忘却一些东西，不应再追忆的便彻底摒弃，太多的留恋会成为一种羁绊。 没有哪一段感情是容易的，若是真爱值得等待，但不是一直等在原地 就算人生是出悲剧，我们要有声有色地演这出悲剧，不要失掉了悲剧的壮丽和快慰； 就算人生是个梦，我们也要有滋有味地做这个梦，不要失掉了梦的情致和乐趣。 ——尼采 青春，是与七个自己相遇。一个明媚，一个忧伤，一个华丽，一个冒险，一个倔强，一个柔软，最后那个正在成长。 她以为自己无所不能，这不，老天都笑话她。纵使她的计策比他高明上无数倍又能如何？乞求爱的人才费尽心机，不爱的人不需要任何手段，所以他不费吹灰之力就可以将她击溃。 忽然都觉得跑得再快也是没有意义的事，雨太急了，站在这样的雨里才深刻体会到所谓的“倾盆”是什么意思，不消五分钟，三人全身上下里里外外湿了个透，一路上也有不少像她们一样的落汤鸡，满载着人的车子一辆辆呼啸而过，坐在上面的都是幸运的人。 墨非定律说，当你越讨厌一个人时，他就会无时无刻不出现在你的面前，而当你想念一个人时，翻遍地球都找不到他。 若干年之后的郑微对涉世不久的小年轻人说的最多的一句话便是：“为人切记张狂，凡事三思而后行。”她无数次回想过去，连自己也不喜欢从前那个被宠坏了的女孩，那么年少轻狂的自以为是，以为谁都得爱她，以为没有什么得不到，然而，当她想到这个晚上，校园里昏黄的路灯下，肩膀上还停留着一片落叶的女孩茫然失措地对着自己爱过的少年说出了心里的那句话，她忽然原谅了当年的自己，那不过是一个太渴望去爱，却不知道到该如何爱的傻孩子。从小人人都疼爱她，但那些爱都不能让她感到安全和满足，她期待一份完全的，值得托付的感情，并且错误地以为只有自己争取来的才是她想要的。如果说年少莽撞是错，那么她后来几年时间里漫长的孤独已然是代价。 阮阮摇头，“我们当时再简单不过了，我没有跟他表白过，他也没有，就水到渠成地在一起了。” 少年人的爱恋，也许爱情方式是错的，然而爱情的直觉永远是对的。 在二十岁到三十岁这十年的过程中，我们都走过一样的路。你觉得孤独就对了，那是让你认识自己的机会。你觉得不被理解就对了，那是让你认清朋友的机会。你觉得黑暗就对了，那样你才分辨得出什么是你的光芒。你觉得无助就对了，那样你才能明白谁是你成长中能扶你一把的人。你觉得迷茫就对了，谁的青春不迷茫。 最后郑微到底有没有和陈孝正在一起 最后林静到底有没有去找施洁 最后老张还在一直送满天星给阮莞么 那个讲师刘云到底是不是朱小北 一切的问号都没有结果 青春本就是个遗憾和回忆共存的产物 我们不能回去弥补过错也对错过无能为力 当黎维娟嫁给一个五十岁大款大叔当了两个孩子的后妈 当阮莞为了结婚而相亲和一个见了六面的男人订婚 当陈孝正开始吸烟为了绿卡和美国女人结婚生子 你会发现成长就是生活逼你成了你最讨厌的人 青春回不去 但即使是脑海里仅存的片段也找不出最恰当的辞藻形容它的美好 我们不能做到青春活得不留遗憾 但要做到在青春里活得心安。 如果这世界上真有奇迹，那只是努力的另一个名字。——《致美丽的你》 When I was young, happiness is a very simple thing; Grew up, simple is very happy. 小时候，幸福 是件很简单的事；长大后，简单是件很幸福的事 希望在20出头的生命里，做一件到八十岁想起来都还会微笑的事。————《我想我已活到了一个尴尬的年龄》 这一生最美好的三个日子: 世界上有你的那天，世界上有我的那天，我和你成为我们的那一天! 世界上只有两种可以称之为浪漫的情感：一种叫相濡以沫，另一种叫相忘于江湖；我们要做的是争取和最爱的人相濡以沫，和次爱的人相忘于江湖。——《爱你，是我做过最好的事》 其实所有漂泊的人，不过是为了有一天能够不再漂泊，能用自己的力量撑起身后的家人和自己爱的人。你觉得最好的生活状态是什么？我觉得最好的生活状态莫过于，在你的青春年纪傻逼地为了理想坚持过，最后回到平淡用现实的方法让自己生活下去。能实现梦想自然是最好，但没能实现自己的梦想那也没有什么可惜的。成长的第一步就是接受这个世界的多样性，认识到现实的不美好，然后还是决定要坚持最初的坚持。 Your heart never lies, but it doesn’t always reveal the truth.你的心从不撒谎，但它也不总能看清真相。 年轻的时候，多忙活点，那是好事，虽然我们经历了岁月的洗礼，经历了许多的磨难，但真挚的感悟没有磨灭，生命是短暂的，而爱情是永恒的。有一个可以思念的人就是幸福。 自由是独立，不依附，不恐惧。一一《与生活相遇》 I can remember all the things that we shared，and the way you smile at me。我记得我们所有的事，和你对我笑的样子 Because I like, so reluctantly, not so much why.因为喜欢，所以情愿，没有那么多为什么 Success is getting what you want; happiness is wanting what you get. -Dale Carnegie. 成功就是得到你想要的，幸福则是喜欢你所得到的。——戴尔 卡耐基 Love is a chord in life,not a solo.爱是生命的和弦，而不是独奏。 Being with you is like walking on a very clear morning. 幸福心理学:两个人在一起，需要面对如此多的困难，所以，爱人永远是可遇而不可求的。你们有着许多的相似，你们存在意识基础层面的高度认同。你们有各自的理想，就会在追逐理想的时候结伴而行。 不管前方的路有多苦，只要走的方向正确，不管多么崎岖不平，都比站在原地更接近幸福。—— 宫泽贤治 Life doesn’t just happen to you; you receive everything in your life based on what you’ve given.一切发生的在你身上的都不是碰巧。你获得什么，在于你付出了什么 我不问，你不说，这就是距离；我问了，你不说，这就是隔阂；我问了，你说了，这就是信任；你不说，我不问，这就是默契；我不问，你说了，这就是依赖！ Suddenly, there was a voice, “Come, Love, I will take you.” It was an elder. So blessed and overjoyed, Love even forgot to ask the elder where they were going. When they arrived at dry land, the elder went her own way. Realizing how much was owed the elder, Love asked Knowledge, another elder, “Who Helped me?”“It was Time,” Knowledge answered.“Time?” asked Love. “But why did Time help me?”Knowledge smiled with deep wisdom and answered, “Because only Time is capable of understanding how valuable Love is.” 不是“晚安”或者“早安”这两个字特别甜蜜和特别重要，而是重要在说的那个人是谁。往往最想听的不是那句话有多动听，而是说的那个人有多真诚。 有时候，坚持了你最不想干的事情之后，便可得到你最想要的东西。——《天空之城》 有些事，一转身就是一辈子。所以，趁年轻，爱你想爱的人，完成你未完成的梦想吧。什么是坚持？就是一天又一天，你告诉自己，再坚持一天。 时间一天天过，好像什么也没改变，但当你回头看，每个人都变了。 迷宫般的城市，让人习惯看相同的景物，走相同的路线，到同样的目的地；习惯让人的生活不再变。习惯让人有种莫名的安全感，却又有种莫名的寂寞。而你，永远不知道，你的习惯会让你错过什么。—-?《向左走，向右走》 你不快乐是因为你可以像只猪一样懒，却无法像只猪一样懒得心安理得。——兔小冷 it’s just that during the time maggie and I were together.we learned a thing or two about fear and about life,we learned that 7 years can count as much as 70 or as 700.and that 10 dollars for a cab may end up being the best investment of your life.watching her was way better than watching the sunset.sometimes life surprises you and hits you with one of those bombshells.a little flaw……there……in the heart.在我和玛姬共同生活的时间里，我们共同一点点理解了恐惧，也慢慢理解了人生，我们知道了7年可以像70年甚至700年一样充实，那用来付出租车钱的10美元也许是对你人生最好的投资，看着她比看任何日落都美好千百倍，有时候生活会用一件意想不到的事让你惊讶，让你受伤，只是心脏上的……一点点小缺陷！——《非常父女档》 路是自己选的，自己总是掌握着方向盘。十年，甚至五年之前我都不能清晰的知道自己要什么，要过什么样的生活，但是一步一步的路让未来生活的轮廓越来越清晰。我不知道我要什么，但是我能知道我不要什么。——《世上另一个我》 【民国结婚证书上的一段美好的话】 “两姓联姻，一堂缔约，良缘永结，匹配同称。看此日桃花灼灼，宜室宜家，卜他年瓜瓞绵绵，尔昌尔炽。谨以白头之约，书向鸿笺，好将红叶之盟，载明鸳谱。此证。” 鸣神の 少しとよみて さし昙り 雨も降らんか 君を留めん鸣神の 少しとよみて 降らずとも 我は止まらん 妹し留めば殷其雷，天霾霾；雨零耶，君将留？殷其雷，纵不零；卿若留，吾将从！-————-——————&lt;&lt;言叶之庭&gt;&gt;]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《活着》]]></title>
    <url>%2F2016%2F06%2F26%2F%E3%80%8A%E6%B4%BB%E7%9D%80%E3%80%8B%2F</url>
    <content type="text"><![CDATA[最近一组震撼心灵的图片《活着》：60岁，每天卸货300吨，每吨6毛，如此辛苦就为了活着。所有的懒惰和矫情再次掉一地碎成渣！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xcode “The file couldn't be opened”]]></title>
    <url>%2F2016%2F06%2F16%2Fxcode-%E2%80%9CThe-file-couldn-t-be-opened%E2%80%9D%2F</url>
    <content type="text"><![CDATA[往往team一起开发时，更新代码后，打开xcode工程文件，会出现 xxx..xcodeproj cannot be opened because the project file cannot be parsed或者xcode “The file couldn’t be open.因为.xcodeproj工程文件冲突了，然后还是会强制更新，内部文件出现了冲突，所以解析不了文件。 会出现这样的冲突消息 < HEAD 1CBABFF91D1120D2008D787F /* 地图找房 */, ======= 24B139BB1D1108FE000F7A75 /* 注册登录 */, >>>>>>> a23e4aae8c7e5f49c973edd63456831a39c53a1d]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS APP转让]]></title>
    <url>%2F2016%2F06%2F08%2FiOS-APP%E8%BD%AC%E8%AE%A9%2F</url>
    <content type="text"><![CDATA[最近提交一款APP，遇到各种坑，提交审核打破纪录，六次提交五次被拒，想想都心酸，还好改到最后终于达到了苹果的“游戏规则”，接着客户说要帮他们把APP转到公司账号上，之前用的是个人账号，参考文档及搜索的资料就有了这篇文章，记录下，其实挺简单的！ 进入itnues connect-&gt;我的app 已经上线的APP会显示以下选项，对于准备提交和被拒的是不会显示的。另外，如果app开了iCloud是不能转让的。 2.点击转让APP会进入如下页面，同意协议继续就行了。 3.接着会看到如下界面，填写接收方的Apple id 及 团队 team id。team id 可以在接收方的account -&gt; membership 中看到。 4.接着根据提示同意协议请求准让即可，接着在“协议,税务和银行业务”可以看到 5.然后进去接受APP的账号。进入itnues connect-&gt;协议,税务和银行业务界面，在Transfer Agreements一栏会看到： 6.点击review，填写相关接受信息，接着点击accept即可。准让很快，感觉也就一两分钟就转让成功了。]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS计算间隔时间]]></title>
    <url>%2F2016%2F05%2F27%2FiOS%E8%AE%A1%E7%AE%97%E9%97%B4%E9%9A%94%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[开发中有时需要计算距离上次的时间间隔： + (NSTimeInterval)getUTCFormateDate:(NSString *)newsDate { //传入日期格式 newsDate = @"2013-08-09 17:01"; NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init]; [dateFormatter setDateFormat:@"yyyy-MM-dd HH:mm"]; NSLog(@"newsDate = %@",newsDate); NSDate *newsDateFormatted = [dateFormatter dateFromString:newsDate]; NSTimeZone *timeZone = [NSTimeZone timeZoneWithName:@"UTC"]; [dateFormatter setTimeZone:timeZone]; NSDate* current_date = [NSDate date]; NSLog(@"current_date = %@",current_date); NSTimeInterval time=[current_date timeIntervalSinceDate:newsDateFormatted];//间隔的秒数 return time; } 界面渲染- (void)renderTopReCheckView:(NSString *)str{ //传入str为日期格式 @"2013-08-09 17:01"; NSTimeInterval dayCountTime = [DateUtils getUTCFormateDate:str]; int month=((int)dayCountTime)/(3600*24*30); int days=((int)dayCountTime)/(3600*24); int hours=((int)dayCountTime)%(3600*24)/3600; int minute=((int)dayCountTime)%(3600*24)/60; int second = ((int)dayCountTime)%(3600*24)%3600%60; NSLog(@"time=%f",(double)dayCountTime); NSString *dateContent; int start = 0; int length = 0; if(month!=0){ dateContent = [NSString stringWithFormat:@" 距离上次检查已经%d%@",month,@"个月"]; start = (int)[dateContent rangeOfString:[NSString stringWithFormat:@"%d",month]].location; length = (int)[dateContent rangeOfString:[NSString stringWithFormat:@"%d",month]].length; }else if(days!=0){ dateContent = [NSString stringWithFormat:@" 距离上次检查已经%d%@",days,@"天"]; start = (int)[dateContent rangeOfString:[NSString stringWithFormat:@"%d",days]].location; length = (int)[dateContent rangeOfString:[NSString stringWithFormat:@"%d",days]].length; }else if(hours!=0){ dateContent = [NSString stringWithFormat:@" 距离上次检查已经%d%@",hours,@"小时"]; start = (int)[dateContent rangeOfString:[NSString stringWithFormat:@"%d",hours]].location; length = (int)[dateContent rangeOfString:[NSString stringWithFormat:@"%d",hours]].length; }else if(minute != 0){ dateContent = [NSString stringWithFormat:@" 距离上次检查已经%d%@",minute,@"分钟"]; start = (int)[dateContent rangeOfString:[NSString stringWithFormat:@"%d",minute]].location; length = (int)[dateContent rangeOfString:[NSString stringWithFormat:@"%d",minute]].length; }else{ dateContent = [NSString stringWithFormat:@" 距离上次检查已经%d%@",second,@"秒"]; start = (int)[dateContent rangeOfString:[NSString stringWithFormat:@"%d",second]].location; length = (int)[dateContent rangeOfString:[NSString stringWithFormat:@"%d",second]].length; } NSMutableAttributedString *attributedText = [[NSMutableAttributedString alloc] initWithString:dateContent]; [attributedText addAttribute:NSForegroundColorAttributeName value:[ColorUtils colorWithHexString:lighter_2_brown_color] range:NSMakeRange(start,length)]; [attributedText addAttribute:NSFontAttributeName value:[UIFont boldSystemFontOfSize:small_font_size] range:NSMakeRange(start,length)]; self.dayCountLbel.attributedText = attributedText; }]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ios对字典进行重新排序]]></title>
    <url>%2F2016%2F04%2F30%2Fios%E5%AF%B9%E5%AD%97%E5%85%B8%E8%BF%9B%E8%A1%8C%E9%87%8D%E6%96%B0%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[NSArray *keys = [self.selectHoleIdAndResultDict allKeys]; NSArray *sortedArray = [keys sortedArrayUsingComparator:^NSComparisonResult(id obj1, id obj2) { NSString *firstStr = [NSString stringWithFormat:@&quot;%@&quot;,obj1]; NSString *secondStr = [NSString stringWithFormat:@&quot;%@&quot;,obj2]; int first = [firstStr intValue]; int second = [secondStr intValue]; NSLog(@&quot;&gt;&gt;&gt;&gt;&gt;%@--%@&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;%d------%d&quot;,obj1,obj2,first,second); return [@(first) compare:@(second)]; }]; for (NSString *categoryId in sortedArray) { NSLog(@&quot;[dict objectForKey:categoryId] =%d== %@&quot;,[categoryId intValue],[self.selectHoleIdAndResultDict objectForKey:categoryId]); [self.selectHoleIdAndResultArray addObject:[self.selectHoleIdAndResultDict objectForKey:categoryId]]; }]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS关于自定义协议]]></title>
    <url>%2F2016%2F04%2F26%2FiOS%E5%85%B3%E4%BA%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[因项目需要展示大量数据并且都是带有时效性的数据，所以首界面的数据包括UI全都是根据后台配置来进行显示的。这样做的好处就是灵活，方便不同的节日，活动等进行相应的配置。那么问题来了，可能一般时候点击某个按钮事件是跳转到一个native界面，有时候是跳转到h5界面，或者有时候触发分享，触发支付等一系列可变的事件。但是假如你的程序写死了，是不能做到这样灵活配置的。这里，我给大家分享一个好的方法:自定义协议。学过计算机的都知道，http协议的组成部分是scheme+域名+path+param组成，而我们自定义协议就是仿http协议来进行动态处理事件。 ios开发中，用户可以在自己的info.plist里配置自己的URL Schemes,例如wechat。自己服务器的域名可以作为协议的域名。这里最关键的就是path部分的定义。我们现在定义如果点击是跳转到native界面 ，path为/native；跳转到h5是/jump；触发分享是/share；触发支付是/pay。这样我们协议的最基本组成部分就出现了:wechat://www.baidu.com/native。后台只需给每个数据都带上这个协议，前台开发中封装一套针对这个协议进行处理的类，即可进行动态处理点击事件。如果我们需要更多的数据，包括动态对界面的UI（比如导航的显示与否）控制，都可以在服务端的协议里进行配置。这样，你的app就是一个灵活性很强的app. 本文引自简书文章]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些常见的状态码]]></title>
    <url>%2F2016%2F04%2F25%2F%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81%2F</url>
    <content type="text"><![CDATA[一些常见的状态码为： 200 – 服务器成功返回网页 404 – 请求的网页不存在 503 – 服务不可用 所有状态解释：点击查看 1xx（临时响应） 表示临时响应并需要请求者继续执行操作的状态代码。 代码 说明 100 （继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。 101 （切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。 2xx （成功）表示成功处理了请求的状态代码。 代码 说明 200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 201 （已创建） 请求成功并且服务器创建了新的资源。 202 （已接受） 服务器已接受请求，但尚未处理。 203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。 204 （无内容） 服务器成功处理了请求，但没有返回任何内容。 205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。 206 （部分内容） 服务器成功处理了部分 GET 请求。 3xx （重定向） 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。 代码 说明 300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。 304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。 307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 4xx（请求错误） 这些状态代码表示请求可能出错，妨碍了服务器的处理。 代码 说明 400 （错误请求） 服务器不理解请求的语法。 401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 403 （禁止） 服务器拒绝请求。 404 （未找到） 服务器找不到请求的网页。 405 （方法禁用） 禁用请求中指定的方法。 406 （不接受） 无法使用请求的内容特性响应请求的网页。 407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。 408 （请求超时） 服务器等候请求时发生超时。 409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。 411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。 412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。 413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。 415 （不支持的媒体类型） 请求的格式不受请求页面的支持。 416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。 417 （未满足期望值） 服务器未满足”期望”请求标头字段的要求。 456 国家代码或手机号码为空 457 手机号码格式错误 466 请求校验的验证码为空 467 请求校验验证码频繁（5分钟内同一个appkey的同一个号码最多只能校验三次） 468 验证码错误 474 没有打开服务端验证开关 5xx（服务器错误） 这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。 代码 说明 500 （服务器内部错误） 服务器遇到错误，无法完成请求。 501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。 503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。 5xx（服务器错误） 这些状态码表示服务器在处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。 500（服务器内部错误） 服务器遇到错误，无法完成请求。 501（尚未实施） 服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。 502（错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。 503（服务不可用） 服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。 504（网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 505（HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Hexo+Github搭建自己的blog]]></title>
    <url>%2F2016%2F04%2F24%2F%E5%9F%BA%E4%BA%8EHexo-Github%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84blog%2F</url>
    <content type="text"><![CDATA[经过各种坑之后，终于搭建好了hexo,之前也一直想要写博客，但是由于自己的懒惰，一直没整理过，所有的笔记也一直是记录在Evernote上，前阶段莫名其妙的自己记录的账号在Evernote上丢失了，才又决定搭建自己的blog。 下面就来进入正题： ##配置环境 1.Node.js 用来生成静态页面的 2.安装Git Mac只要安装Xcode就会自带git 3.申请GitHub账号 ###我个人所使用的各环境版本 hexo: 3.2.0 node: 5.10.0 git version 2.6.4]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ios 错误总结]]></title>
    <url>%2F2016%2F04%2F24%2Fios-%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[fatal error: file '/Applications/Xcode.appContents/Developer/Platforms/iPhoneSimulator.platform/Dev 类似这样的错误：fatal error: file &apos;/Applications/Xcode.app/Contents/Developer/Platforms/ iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator8.1.sdk/Sste/ Library/Frameworks/UIKit.framework/Headers/UITableView.h&apos; has been modified since the precompiled header &apos;/Users/weixuewu/Library/ Developer/Xcode/DerivedData/JiaoWuXiTong-grltjakjujuowvcvrkqlqrwpbqfr/ Build/Intermediates/PrecompiledHeaders/Pods-AFNetworking-prefix- esbdmbdlgmazudenvxmluxydclkd/Pods-AFNetworking-prefix.pch.pch&apos; was built note: &apos;/Applications/Xcode.app/Contents/Developer/Platforms/ iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator8.1.sdk/System/ Library/Frameworks/UIKit.framework/Headers/UITableView.h&apos; required by &apos;/ Users/weixuewu/Library/Developer/Xcode/DerivedData/ModuleCache/ 3HIREQHFIR4KN/UIKit-2M4VYLEDI34V0.pcm&apos; note: &apos;/Users/weixuewu/Library/Developer/Xcode/DerivedData/ModuleCache/ 3HIREQHFIR4KN/UIKit-2M4VYLEDI34V0.pcm&apos; required by &apos;/Users/weixuewu/ Library/Developer/Xcode/DerivedData/JiaoWuXiTong- grltjakjujuowvcvrkqlqrwpbqfr/Build/Intermediates/PrecompiledHeaders/Pods- AFNetworking-prefix-esbdmbdlgmazudenvxmluxydclkd/Pods-AFNetworking- prefix.pch.pch&apos; note: please rebuild precompiled header &apos;/Users/weixuewu/Library/ Developer/Xcode/DerivedData/JiaoWuXiTong-grltjakjujuowvcvrkqlqrwpbqfr/ Build/Intermediates/PrecompiledHeaders/Pods-AFNetworking-prefix- esbdmbdlgmazudenvxmluxydclkd/Pods-AFNetworking-prefix.pch.pch&apos; 1 error generated. 解决方法：找出note标记的pcm文件地址： /Users/weixuewu/Library/Developer/Xcode/DerivedData/ModuleCache/3HIREQHFIR4KN/UIKit-2M4VYLEDI34V0.pcm 然后删除，重新编译即可]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
</search>
