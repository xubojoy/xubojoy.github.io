<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>KVO实现原理 | 枫林飘雪</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="官方文档这么写：  Automatic key-value observing is implemented using a technique called isa-swizzling…When an observer is registered for an attribute of an object the isa pointer of the observed object is mod">
<meta name="keywords" content="ios">
<meta property="og:type" content="article">
<meta property="og:title" content="KVO实现原理">
<meta property="og:url" content="http://xubojoy.github.io/2018/03/05/KVO实现原理/index.html">
<meta property="og:site_name" content="枫林飘雪">
<meta property="og:description" content="官方文档这么写：  Automatic key-value observing is implemented using a technique called isa-swizzling…When an observer is registered for an attribute of an object the isa pointer of the observed object is mod">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://xubojoy.github.io/2018/03/05/KVO实现原理/1.png">
<meta property="og:image" content="http://xubojoy.github.io/2018/03/05/KVO实现原理/2.png">
<meta property="og:updated_time" content="2018-03-07T10:24:19.528Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="KVO实现原理">
<meta name="twitter:description" content="官方文档这么写：  Automatic key-value observing is implemented using a technique called isa-swizzling…When an observer is registered for an attribute of an object the isa pointer of the observed object is mod">
<meta name="twitter:image" content="http://xubojoy.github.io/2018/03/05/KVO实现原理/1.png">
  
    <link rel="alternate" href="/atom.xml" title="枫林飘雪" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">枫林飘雪</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">成事不说，遂事不谏，既往不咎!   继续修行！！！</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://xubojoy.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-KVO实现原理" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/05/KVO实现原理/" class="article-date">
  <time datetime="2018-03-05T07:22:17.000Z" itemprop="datePublished">2018-03-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/ios/">ios</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      KVO实现原理
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>官方文档这么写：</p>
<blockquote>
<p>Automatic key-value observing is implemented using a technique called isa-swizzling…When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing toan intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual classof the instance.</p>
</blockquote>
<p>对于KVO实现的原理，苹果官方文档描述的比较少，从中只能知道苹果使用了一张叫做isa-swizzling的黑魔法…</p>
<a id="more"></a>
<p>其实，当某个类的对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类（类名就是在该类的前面加上<code>NSKVONotifying_  前缀</code>），在这个派生类中重写基类中任何被观察属性的 setter 方法。</p>
<p>派生类在被重写的 setter 方法实现真正的通知机制，就如前面手动实现键值观察那样，调用<code>willChangeValueForKey:</code>和<code>didChangeValueForKey:</code>方法。这么做是基于设置属性会调用 setter 方法，而通过重写就获得了 KVO 需要的通知机制。当然前提是要通过遵循 KVO 的属性设置方式来变更属性值，如果仅是直接修改属性对应的成员变量，是无法实现 KVO 的。</p>
<p>同时派生类还重写了 class 方法以“欺骗”外部调用者它就是起初的那个类。然后系统将这个对象的 isa 指针指向这个新诞生的派生类，因此这个对象就成为该派生类的对象了，因而在该对象上对 setter 的调用就会调用重写的 setter，从而激活键值通知机制。此外，派生类还重写了 dealloc 方法来释放资源。</p>
<p>文章结构如下：</p>
<p>Why?  （为什么要用KVO）</p>
<p>What? （KVO是什么）</p>
<p>How? （ KVO怎么用）</p>
<p>More （更多细节）</p>
<p>原理</p>
<p>自己实现KVO</p>
<p>在我的上一篇文章浅谈 <code>iOS Notification</code>中，我们说到了iOS中观察者模式的一种实现方式：<code>NSNotification</code> 通知，这次我们再来谈谈iOS中观察者模式的另一种实现方式：KVO 。</p>
<p>Why？</p>
<p>假如，有一个<code>person</code>类，和一个<code>Account</code>类，<code>account</code>类中又有两个公开的属性，<code>balance</code>和<code>interestRate</code>，当<code>account</code>中的<code>balance</code>和<code>interestRate</code>发生变化时，需要知道通知到这个<code>person</code>，这个要求很正常，我的银行账户里的钱增加或减少了我当然要及时知道啊。有人可能会想，每隔一段时间去轮询<code>Account</code>中的<code>balance</code>和<code>interestRate</code>，当其发生变化就通知<code>person</code>，但是这样做不仅低效而且通知也不能及时发出。</p>
<p><img src="/2018/03/05/KVO实现原理/1.png" alt="1"></p>
<p>这个时候KVO就派上用场了。</p>
<p>What？</p>
<p>KVO到底是什么呢？不着急，要说KVO还得先说下KVC，<code>KVC（Key-value coding）</code>是一种基于<code>NSKeyValueCoding</code>非正式协议的机制，能让我们直接使用一个或一串字符串标识符去访问，操作类的属性。<br>常用的方法比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (nullable id)valueForKey:(NSString *)key;</span><br><span class="line">- (void)setValue:(nullable id)value forKey:(NSString *)key;</span><br><span class="line">- (nullable id)valueForKeyPath:(NSString *)keyPath;</span><br><span class="line">- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath;</span><br></pre></td></tr></table></figure>
<p>通过这些方法加上正确的标识符(一般和属性同名)，可以直接获取或者设置一个类的属性，甚至可以轻易越过多个类的层级结构，直接获取目标属性。</p>
<p><img src="/2018/03/05/KVO实现原理/2.png" alt="1"></p>
<p>KVC还提供了集合操作的方法，直接获取到集合属性的同时还能对其进行求和，取平均数，求最大最小值等操作，如下为求和操作，具体可以到苹果官方文档详细了解。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSNumber *amountSum = [self.transactions valueForKeyPath:@&quot;@sum.amount&quot;];</span><br></pre></td></tr></table></figure>
<p>KVO</p>
<p><code>KVO (Key-Value Observing)</code> 是Cocoa提供的一种基于KVC的机制，允许一个对象去监听另一个对象的某个属性，当该属性改变时系统会去通知监听的对象(不是被监听的对象)。</p>
<p>上面那个例子如果用KVO实现的话，大概就是，用<code>Person</code>类的一个对象去监听<code>Account</code>类的一个对象的属性，然后当<code>Account</code>类对象的相应属性改变时，<code>Person</code>类的对象就会收到通知。这也是iOS种观察者模式的一种实现方式。</p>
<p>也就是说，一般情况下，任何一个对象可以监听任何一个对象（当然也包括自己本身）的任意属性，然后在其属性变化后收到通知。</p>
<p>How?</p>
<p>那么KVO怎么用呢？KVO的使用步骤主要分为3步：添加监听，接收通知和移除监听。</p>
<ol>
<li>添加监听</li>
</ol>
<p>通过以下方法添加一个监听者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context;</span><br></pre></td></tr></table></figure>
<p>我们重点关注一下这个方法的4个参数：</p>
<p>observer：就是要添加的监听者对象，，当监听的属性发生改变时就会去通知该对象，该对象必须实现<br><code>-observeValueForKeyPath:ofObject:change:context:</code>方法，要不然当监听的属性的改变通知发出来，却发现没有相应的接收方法时，程序会抛出异常。</p>
<p>keyPath：就是要被监听的属性，这里和KVC的规则一样。但是这个值不能传nil，要不然会报错。通常我们在用的时候会传一个与属性同名的字符串，但是这样可能会因为拼写错误，导致监听不成功，一个推荐的做法是，用这种方式<code>NSStringFromSelector(@selector(propertyName))</code>，其实就是是将属性的getter方法转换成了字符串，这样做的好处就是，如果你写错了属性名，xcode会用警告提醒你。</p>
<p>options：是一些配置选项，用来指明通知发出的时机和通知响应方法<br><code>observeValueForKeyPath:ofObject:change:context:</code>的change字典中包含哪些值，它的取值有4个，定义在<code>NSKeyValueObservingOptions</code>中，可以用|符号连接，如下：</p>
<blockquote>
<p><code>NSKeyValueObservingOptionNew</code>：指明接受通知方法参数中的change字典中应该包含改变后的新值。</p>
</blockquote>
<blockquote>
<p><code>NSKeyValueObservingOptionOld</code>: 指明接受通知方法参数中的change字典中应该包含改变前的旧值。</p>
</blockquote>
<blockquote>
<p><code>NSKeyValueObservingOptionInitial</code>: 当指定了这个选项时，在addObserver:forKeyPath:options:context:消息被发出去后，甚至不用等待这个消息返回，监听者对象会马上收到一个通知。这种通知只会发送一次，你可以利用这种“一次性“的通知来确定要监听属性的初始值。当同时制定这3个选项时，这种通知的change字典中只会包含新值，而不会包含旧值。虽然这时候的新值实际上是改变前的’旧值’，但是这个值对于监听者来说是新的。</p>
</blockquote>
<blockquote>
<p><code>NSKeyValueObservingOptionPrior</code>：当指定了这个选项时，在被监听的属性被改变前，监听者对象就会收到一个通知（一般的通知发出时机都是在属性改变后，虽然change字典中包含了新值和旧值，但是通知还是在属性改变后才发出），这个通知会包含一个<code>NSKeyValueChangeNotificationIsPriorKeykey</code>，其对应的值为一个NSNumber类型的YES。当同时指定该值、new和old的话，change字典会包含旧值而不会包含新值。你可以在这个通知中调用</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)willChangeValueForKey:(NSString *)key;</span><br></pre></td></tr></table></figure>
<p>context：添加监听方法的最后一个参数，是一个可选的参数，可以传任何数据，这个参数最后会被传到监听者的响应方法中，可以用来区分不同通知，也可以用来传值。如果你要用context来区分不同的通知，一个推荐的做法是声明一个静态变量，其保持它自己的地址，这个变量没有什么意义，但是却能起到区分的作用，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static void *PersonAccountBalanceContext = &amp;PersonAccountBalanceContext;</span><br><span class="line">static void *PersonAccountInterestRateContext = &amp;PersonAccountInterestRateContext;</span><br></pre></td></tr></table></figure>
<p>然后，结合上面Person，account的例子，我们可以给Account对象添加监听：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)registerAsObserverForAccount:(Account*)account &#123;</span><br><span class="line">  [account addObserver:self</span><br><span class="line">            forKeyPath:@&quot;balance&quot;</span><br><span class="line">               options:(NSKeyValueObservingOptionNew |</span><br><span class="line">                        NSKeyValueObservingOptionOld)</span><br><span class="line">               context:PersonAccountBalanceContext];</span><br><span class="line"> </span><br><span class="line">  [account addObserver:self</span><br><span class="line">            forKeyPath:@&quot;interestRate&quot;</span><br><span class="line">               options:(NSKeyValueObservingOptionNew |</span><br><span class="line">                        NSKeyValueObservingOptionOld)</span><br><span class="line">                context:PersonAccountInterestRateContext];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，添加监听的方法<code>addObserver:forKeyPath:options:context:</code>并不会对监听和被监听的对象以及context做强引用，你必须自己保证他们在监听过程中不被释放。</p>
<ol start="2">
<li>接受通知</li>
</ol>
<p>前面说过了，每一个监听者对象都必须实现下面这个方法来接收通知：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(nullable NSString *)keyPath ofObject:(nullable id)object change:(nullable NSDictionary&lt;nskeyvaluechangekey, id&gt; *)change context:(nullable void *)context;</span><br></pre></td></tr></table></figure>
<p>keyPath，object，context和监听方法中指定的一样，关于change参数，它是一个字典，有五个常量作为它的键：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">NSString *const NSKeyValueChangeKindKey;  </span><br><span class="line"></span><br><span class="line">NSString *const NSKeyValueChangeNewKey;  </span><br><span class="line"></span><br><span class="line">NSString *const NSKeyValueChangeOldKey;  </span><br><span class="line"></span><br><span class="line">NSString *const NSKeyValueChangeIndexesKey;  </span><br><span class="line"></span><br><span class="line">NSString *const NSKeyValueChangeNotificationIsPriorKey;</span><br></pre></td></tr></table></figure>
<p>一个一个分析下：</p>
<p>NSKeyValueChangeKindKey：指明了变更的类型，值为“NSKeyValueChange”枚举中的某一个，类型为NSNumber。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;</span><br><span class="line"> NSKeyValueChangeSetting = 1,</span><br><span class="line"> NSKeyValueChangeInsertion = 2,</span><br><span class="line"> NSKeyValueChangeRemoval = 3,</span><br><span class="line"> NSKeyValueChangeReplacement = 4</span><br><span class="line">&#125;;</span><br><span class="line">typedef NSUInteger NSKeyValueChange;</span><br></pre></td></tr></table></figure>
<p>一般情况下返回的都是1也就是第一个NSKeyValueChangeSetting，但是如果你监听的属性是一个集合对象的话，当这个集合中的元素被插入，删除，替换时，就会分别返回<code>NSKeyValueChangeInsertion</code>，<code>NSKeyValueChangeRemoval</code>和<code>NSKeyValueChangeReplacement</code>。</p>
<p><code>NSKeyValueChangeNewKey：</code>被监听属性改变后新值的key，当监听属性为一个集合对象，且<code>NSKeyValueChangeKindKey</code>不为<code>NSKeyValueChangeSetting</code>时，该值返回的是一个数组，包含插入，替换后的新值（删除操作不会返回新值）。</p>
<p><code>NSKeyValueChangeOldKey：</code>被监听属性改变前旧值的key，当监听属性为一个集合对象，且<code>NSKeyValueChangeKindKey</code>不为<code>NSKeyValueChangeSetting</code>时，该值返回的是一个数组，包含删除，替换前的旧值（插入操作不会返回旧值）</p>
<p><code>NSKeyValueChangeIndexesKey：</code>如果<code>NSKeyValueChangeKindKey</code>的值为<code>NSKeyValueChangeInsertion</code>, <code>NSKeyValueChangeRemoval</code>, 或者 <code>NSKeyValueChangeReplacement</code>，这个键的值是一个<code>NSIndexSet</code>对象，包含了增加，移除或者替换对象的index。</p>
<p><code>NSKeyValueChangeNotificationIsPriorKey：</code>如果注册监听者是options中指明了<code>NSKeyValueObservingOptionPrior</code>，change字典中就会带有这个key，值为NSNumber类型的YES.</p>
<p>最后，完整的change字典大概就类似这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSDictionary *change = @&#123;</span><br><span class="line">                         NSKeyValueChangeKindKey : NSKeyValueChange(枚举值),</span><br><span class="line">                         NSKeyValueChangeNewKey : newValue,</span><br><span class="line">                         NSKeyValueChangeOldKey : oldValue,</span><br><span class="line">                         NSKeyValueChangeIndexesKey : @[NSIndexSet, NSIndexSet],</span><br><span class="line">                         NSKeyValueChangeNotificationIsPriorKey : @1,</span><br><span class="line">                         &#125;;</span><br></pre></td></tr></table></figure>
<p>继续用上面的例子实现接受通知如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath</span><br><span class="line">                      ofObject:(id)object</span><br><span class="line">                        change:(NSDictionary *)change</span><br><span class="line">                       context:(void *)context &#123;</span><br><span class="line"> </span><br><span class="line">   if (context == PersonAccountBalanceContext) &#123;</span><br><span class="line">        // Do something with the balance…</span><br><span class="line"> </span><br><span class="line">    &#125; else if (context == PersonAccountInterestRateContext) &#123;</span><br><span class="line">        // Do something with the interest rate…</span><br><span class="line"> </span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // Any unrecognized context must belong to super</span><br><span class="line">        [super observeValueForKeyPath:keyPath</span><br><span class="line">                             ofObject:object</span><br><span class="line">                               change:change</span><br><span class="line">                               context:context];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以通过context或者keypath来区分不同的通知，但是要注意的是，正如上面实例代码中那样，当接收到一个不能识别的context或者keypath的话，需要调用一下父类的<br><code>observeValueForKeyPath:ofObject:change:context:</code>方法</p>
<ol start="3">
<li>移除监听</li>
</ol>
<p>当一个监听者完成了它的监听任务之后，就需要注销(移除)监听者，调用以下2个方法来移除监听。通常会在-dealloc方法或者<code>observeValueForKeyPath:ofObject:change:context:</code>方法中移除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath context:(nullable void *)context</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath;</span><br></pre></td></tr></table></figure>
<p>有几点需要注意的：</p>
<p>当你向一个不是监听者的对象发送remove消息的时候（也可能是，你发送remove消息时，接受消息的对象已经被remove了一次，或者在注册为监听者前就调用了remove），xcode会抛出一个<code>NSRangeException</code>异常，所以，保险的做法是，把remove操作放在<code>try/catch</code>中。</p>
<p>一个监听者在其被销毁时，并不会自己注销监听，而给一个已经销毁的监听者发送通知，会造成野指针错误。所以至少保证，在监听者被释放前，将其监听注销。保证有一个add方法，就有一个remove方法。</p>
<p>More</p>
<p>再说更多的一些东西，想让类的某个属性支持KVO机制的话，这个类必须满足一下3点：</p>
<p>这个类必须使得该属性支持KVC。</p>
<p>这个类必须保证能够将改变通知发出。</p>
<p>当有依赖关系的时候，注册合适的依赖键。</p>
<p>第一个条件：这个类必须使得该属性支持KVC</p>
<p>就是需要实现与该属性对应的getter和setter方法和其他一些可选方法。幸运的是，NSObject类已经帮我们实现了这些，只要你的类最终是继承自NSObject，并且使用正常的方式创建属性，这些属性都是支持KVO的。</p>
<p>KVO支持的类型和KVC一样，包括对象类型，标量（例如 int 和 CGFloat）和 struct（例如 CGRect）。</p>
<p>第二个条件：这个类必须保证能够将改变通知发出。</p>
<p>通知发出的方式又分为自动通知和手动通知：</p>
<ul>
<li>自动通知</li>
</ul>
<p>自动通知由NSObject默认实现了，也就是说一般情况下，你不用写额外的一些代码，属性改变的通知就会自动发出，这也是我们平常开发中接触最多的。</p>
<p>触发自动通知发出的方式包括下面这些：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Call the accessor method.</span><br><span class="line">[account setName:@&quot;Savings&quot;];</span><br><span class="line"> </span><br><span class="line">// Use setValue:forKey:.</span><br><span class="line">[account setValue:@&quot;Savings&quot; forKey:@&quot;name&quot;];</span><br><span class="line"> </span><br><span class="line">// Use a key path, where &apos;account&apos; is a kvc-compliant property of &apos;document&apos;.</span><br><span class="line">[document setValue:@&quot;Savings&quot; forKeyPath:@&quot;account.name&quot;];</span><br><span class="line"> </span><br><span class="line">// Use mutableArrayValueForKey: to retrieve a relationship proxy object.</span><br><span class="line">Transaction *newTransaction = &lt;#Create a new transaction for the account#&gt;;</span><br><span class="line">NSMutableArray *transactions = [account mutableArrayValueForKey:@&quot;transactions&quot;];</span><br><span class="line">[transactions addObject:newTransaction];</span><br></pre></td></tr></table></figure>
<p>其中包括调用setter方法，调用KVC的<code>setValue:forKey:</code>和<code>setValue:forKeyPath:</code>,最后一个方法需要说一下,<code>mutableArrayValueForKey:</code>也是KVC的方法，大家应该都知道，如果你用KVO监听了一个集合对象（比如一个数组），当你给数组发送<code>addObject:</code>消息时，是不会触发KVO通知的，但是通过<code>mutableArrayValueForKey:</code>这个方法对集合对象进行的相关操作（增加，删除，替换元素）就会触发KVO通知，这个方法会返回一个中间代理对象，这个中间代理对象的类会指向一个中间类，你在这个代理对象上进行的操作最终应在原始对象上造成同样的效果。</p>
<ul>
<li>手动通知</li>
</ul>
<p>有时候，你可能会想控制通知的发送，比如，阻止一些不必要的通知发出，或者把一组类似的通知合并成一个，这时候就需要手动发送通知了。</p>
<p>首先，你需要重写NSObject的一个类方法，来指明你不想让哪个属性的改变通知自动发出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)theKey &#123;</span><br><span class="line"> </span><br><span class="line">  BOOL automatic = NO;</span><br><span class="line">  if ([theKey isEqualToString:@&quot;balance&quot;]) &#123;</span><br><span class="line">      automatic = NO;</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">      automatic = [super automaticallyNotifiesObserversForKey:theKey];</span><br><span class="line">  &#125;</span><br><span class="line">  return automatic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，return NO就可以阻止，该key对应的属性改变时，通知不会自动发送给监听者对象，当然对于其他的属性别忘了调用super方法保持它原来的状态。（改方法默认返回YES）</p>
<p>然后，你需要重写你想手动发送通知属性的setter方法，然后在属性值改变之前和之后分别调用willChangeValueForKey:和didChangeValueForKey:方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)setBalance:(double)theBalance &#123;</span><br><span class="line">  [self willChangeValueForKey:@&quot;balance&quot;];</span><br><span class="line">  _balance = theBalance;</span><br><span class="line">  [self didChangeValueForKey:@&quot;balance&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就基本实现了一个KVO的手动通知，当该属性值改变时，监听者对象就能收到改变通知了。</p>
<p>你还可以过滤一些通知，像下面的例子就是只有当属性真正改变时才会发出通知</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)setBalance:(double)theBalance &#123;  if (theBalance != _balance) &#123;</span><br><span class="line">      [self willChangeValueForKey:@&quot;balance&quot;];</span><br><span class="line">      _balance = theBalance;</span><br><span class="line">      [self didChangeValueForKey:@&quot;balance&quot;];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个操作导致了多个键的变化，你必须嵌套变更通知：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)setBalance:(double)theBalance &#123;</span><br><span class="line">  [self willChangeValueForKey:@&quot;balance&quot;];</span><br><span class="line">  [self willChangeValueForKey:@&quot;itemChanged&quot;];</span><br><span class="line">  _balance = theBalance;</span><br><span class="line">  _itemChanged = _itemChanged+1;</span><br><span class="line">  [self didChangeValueForKey:@&quot;itemChanged&quot;];</span><br><span class="line">  [self didChangeValueForKey:@&quot;balance&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在to-many关系操作的情形中，你不仅必须表明key是什么，还要表明变更类型和影响到的索引。变更类型是一个 NSKeyValueChange值，被影响对象的索引是一个 NSIndexSet对象。</p>
<p>下面的代码示范了在to-many关系transactions对象中的删除操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)removeTransactionsAtIndexes:(NSIndexSet *)indexes &#123;</span><br><span class="line">  [self willChange:NSKeyValueChangeRemoval</span><br><span class="line">      valuesAtIndexes:indexes forKey:@&quot;transactions&quot;];</span><br><span class="line"> </span><br><span class="line">  // Remove the transaction objects at the specified indexes.</span><br><span class="line"> </span><br><span class="line">  [self didChange:NSKeyValueChangeRemoval</span><br><span class="line">      valuesAtIndexes:indexes forKey:@&quot;transactions&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三个条件：这个类必须使得该属性支持KVC</p>
<p>有时候会存在这样一种情况，一个属性的改变依赖于别的一个或多个属性的改变，也就是说当别的属性改了，这个属性也会跟着改变，比如说一个人的全名fullName包括firstName和lastName，当firstName或者lastName中任何一个值改变了，fullName也就改变了。一个监听者监听了fullName，当firstName或者lastName改变时，这个监听者也应该被通知。</p>
<p>一种方法就是重写keyPathsForValuesAffectingValueForKey:方法去指明fullName属性是依赖于lastName和firstName的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ (NSSet *)keyPathsForValuesAffectingValueForKey:(NSString *)key &#123;</span><br><span class="line"> </span><br><span class="line">  NSSet *keyPaths = [super keyPathsForValuesAffectingValueForKey:key];</span><br><span class="line">   </span><br><span class="line">  if ([key isEqualToString:@&quot;fullName&quot;]) &#123;</span><br><span class="line">      NSArray *affectingKeys = @[@&quot;lastName&quot;, @&quot;firstName&quot;];</span><br><span class="line">      keyPaths = [keyPaths setByAddingObjectsFromArray:affectingKeys];</span><br><span class="line">  &#125;</span><br><span class="line">  return keyPaths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种实现同样结果的方法是实现一个遵循命名方式为<code>keyPathsForValuesAffecting</code>的类方法，是依赖于其他值的属性名（首字母大写），用上面代码的例子来重新实现一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (NSSet *)keyPathsForValuesAffectingFullName &#123;</span><br><span class="line">  return [NSSet setWithObjects:@&quot;lastName&quot;, @&quot;firstName&quot;, nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是在To-many Relationships中（比如数组属性），上面的方法就不管用了，比如，假如你有一个Department类，它有一个针对Employee类的to-many关系（即拥有一个装有Employee类对象的数组），Employee类有salary属性。你希望Department类有一个totalSalary属性来计算所有员工的薪水，也就是在这个关系中Department的totalSalary依赖于所有Employee的salary属性。这种情况你不能通过实现<code>keyPathsForValuesAffectingTotalSalary</code>方法并返回employees.salary。</p>
<p>有两种解决方法：</p>
<p>1.你可以用KVO将parent（比如Department）作为所有children（比如Employee）相关属性的观察者。你必须在把child添加或删除到parent时也把parent作为child的观察者添加或删除。在<code>observeValueForKeyPath:ofObject:change:context:</code>方法中我们可以针对被依赖项的变更来更新依赖项的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context &#123;</span><br><span class="line"> </span><br><span class="line">if (context == totalSalaryContext) &#123;</span><br><span class="line">   [self updateTotalSalary];</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">// deal with other observations and/or invoke super...</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (void)updateTotalSalary &#123;</span><br><span class="line">[self setTotalSalary:[self valueForKeyPath:@&quot;employees.@sum.salary&quot;]];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (void)setTotalSalary:(NSNumber *)newTotalSalary &#123;</span><br><span class="line"> </span><br><span class="line">if (totalSalary != newTotalSalary) &#123;</span><br><span class="line">   [self willChangeValueForKey:@&quot;totalSalary&quot;];</span><br><span class="line">   _totalSalary = newTotalSalary;</span><br><span class="line">   [self didChangeValueForKey:@&quot;totalSalary&quot;];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (NSNumber *)totalSalary &#123;</span><br><span class="line">return _totalSalary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用iOS中观察者模式的另一种实现方式：通知 (NSNotification) ，有关通知相关的概念和用法，可以参考我上一篇文章 浅谈 <a href="https://www.jianshu.com/p/8832f019c17f" target="_blank" rel="noopener">iOS Notification</a> 。</p>
<p>参考：<br><a href="http://www.cocoachina.com/ios/20161222/18417.html" target="_blank" rel="noopener">原文链接</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xubojoy.github.io/2018/03/05/KVO实现原理/" data-id="cjs1ew6qk000m6os6ksnfwkw9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ios/">ios</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/03/05/KVC实现原理/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          KVC实现原理
        
      </div>
    </a>
  
  
    <a href="/2018/03/05/线程安全以及nonatomic和atomic/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">线程安全以及nonatomic和atomic</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ios/">ios</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器/">服务器</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活/">生活</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ios/">ios</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务器/">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/生活/">生活</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/随笔/">随笔</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Python/" style="font-size: 13.33px;">Python</a> <a href="/tags/ios/" style="font-size: 20px;">ios</a> <a href="/tags/数据库/" style="font-size: 10px;">数据库</a> <a href="/tags/服务器/" style="font-size: 16.67px;">服务器</a> <a href="/tags/生活/" style="font-size: 16.67px;">生活</a> <a href="/tags/随笔/" style="font-size: 10px;">随笔</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/01/29/新年来场与-面试-有关的约会/">新年来场与&#39;面试&#39;有关的约会</a>
          </li>
        
          <li>
            <a href="/2019/01/01/写在2019年的开端/">写在2019年的开端</a>
          </li>
        
          <li>
            <a href="/2018/11/27/解决Xcode10-import不提示问题/">解决Xcode10 #import不提示问题</a>
          </li>
        
          <li>
            <a href="/2018/11/01/使用shell脚本打包IPA，导出并上传到蒲公英/">使用shell脚本打包IPA，导出并上传到蒲公英</a>
          </li>
        
          <li>
            <a href="/2018/08/13/SDWebImage原理和缓存机制/">SDWebImage原理和缓存机制</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 枫林飘雪<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>